<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LiquidTechnologies.XmlObjects.Runtime</name>
    </assembly>
    <members>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxRuntimeRequirementsAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxComplexTypeDefinitionAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxCompositorDefinitionAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementDefinitionAttribute">
            <summary>
            Attaches to a class an indicates that it represents an element defintion.
            </summary>
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxRestrictedPropertyAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxRestrictionAttribute">
            <summary>
            Indicates the class is a restriction of the base class
            </summary>
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxRestrictionExcludeProperty">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxSimpleComplexTypeDefinitionAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxSimpleElementDefinitionAttribute">
            <summary>
            Attaches to a class an indicates that it represents an element definition.
            </summary>
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.CompositorType">
            <summary>
            Represents the type of xsd compositor
            </summary>
            <exclude />
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.Attribution.CompositorType.All">
            <summary>
            represents an xs:all (all of the child options must be populated, but can appear in the XML in any order)
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.Attribution.CompositorType.Choice">
            <summary>
            represents an xs:choice (One and only one, of the child options can be populated)
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.Attribution.CompositorType.Sequence">
            <summary>
            represents an xs:sequence (all of the child options must be populated, but must appear in the order they are defined)
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.Attribution.CompositorType.Simple">
            <summary>
            represents the GenerationMode Simple, where all the child elements are unordered and cardinality rules are not applied
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.ElementScopeType">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.ExplicitTimezoneType">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.ILxCardinality">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.ILxValueAttribute">
            <exclude />
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Attribution.ILxValueAttribute.NumericPattern">
            <summary>
            Determines how a numeric value will be converted to a string in order to be serialized.
            This is not an XSD facet, its a additional formatting rules that must be configured, either using the extension notation in the source XSD or an external caddy file.
            </summary>
            <remarks>
            Can only be applied to numeric data types (i.e. decimal, precisionDecimal, double, float, long, int, short, byte, unsignedlong, unsignedint, 
            unsignedShort, unsignedByte, Integer, positiveInteger, negativeInteger, nonNegativeInteger, nonPositiveInteger).
            The formatting rules are described in <see href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings">Standard numeric format strings</see>
            and <see href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings">Custom numeric format strings</see>
            </remarks>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxEnumValueAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxPropertyAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxValueType">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.OpenContentModeType">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxAttributeAnyAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxTestAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxAttributeAttribute">
            <exclude />
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Attribution.LxAttributeAttribute.NumericPattern">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.Attribution.ILxValueAttribute.NumericPattern"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxAttributeBaseAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxAttributeUnprocessedAttribute">
            <summary>
            Indicates the class is a restriction of the base class
            </summary>
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementAlternativeAttribute">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Attribution.LxElementAlternativeAttribute.#ctor(System.Type,System.String)">
            <summary>
            
            </summary>
            <param name="alternativeType">If this is null then it is considered to represent xs:error</param>
            <param name="xpathTest">If this is null then there is no test, so its considered to be always true</param>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementAnyAttribute">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Attribution.LxElementAnyAttribute.CanBeEmpty(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Indicates if the property can be empty (either because its got minOccurs  = 0 or 
            because the property does not define an element and everything in it that does is optional)
            This typically happens if its a compositor and all the items in it are optional.
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementBaseAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementCompositorAttribute">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Attribution.LxElementCompositorAttribute.CanBeEmpty(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Indicates if the property can be empty (either because its got minOccurs  = 0 or 
            because the property does not define an element and everything in it that does is optional)
            This typically happens if its a compositor and all the items in it are optional.
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementCtAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementNamedAttribute">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Attribution.LxElementNamedAttribute.CanBeEmpty(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Indicates if the property can be empty (either because its got minOccurs  = 0 or 
            because the property does not define an element and everything in it that does is optional)
            This typically happens if its a compositor and all the items in it are optional.
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementRawAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementRefAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementSubstGrpAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementUnprocessedAttribute">
            <summary>
            Indicates the class is a restriction of the base class
            </summary>
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementValueAttribute">
            <exclude />
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Attribution.LxElementValueAttribute.NumericPattern">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.Attribution.ILxValueAttribute.NumericPattern"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxElementWithCardinalityAttribute">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Attribution.LxElementWithCardinalityAttribute.IsPropertyValueEmpty(System.Object)">
            <summary>
            Indicates if the property contains a value
                this means null if its a 0-1 or 1-1
                or an empty collection if its 0-n
            </summary>
            <param name="sourceObject"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Attribution.LxElementWithCardinalityAttribute.CanBeEmpty(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Indicates if the property can be empty (either because its got minOccurs  = 0 or 
            because the property does not define an element and everything in it that does is optional)
            This typically happens if its a compositor and all the items in it are optional.
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxOpenContentAttribute">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxUnionAttribute">
            <exclude />
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Attribution.LxUnionAttribute.NumericPattern">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.Attribution.ILxValueAttribute.NumericPattern"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.LxValueAttribute">
            <exclude />
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Attribution.LxValueAttribute.NumericPattern">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.Attribution.ILxValueAttribute.NumericPattern"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.WhiteSpaceType">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Attribution.XsdType">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.BinaryUtilities">
            <summary>
            Utility class for working with binary data
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BinaryUtilities.HexDecode(System.String)">
            <summary>
            Converts a string of hex encoded chars to a byte array
            outside the accepted range (0-9 a-f A-F)
            </summary>
            <param name="s"></param>
            <returns>The byte array represented by the string</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws if the string contains an odd number of chars our chars</exception>
            <exception cref="T:System.FormatException">Throws if the string contains invalid chars</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BinaryUtilities.TryHexDecode(System.String,System.Byte[]@,System.Exception@)">
            <summary>
            Attempts to parse an array of chars as a hex encoded string
            </summary>
            <param name="s">the hex encoded string to be decoded</param>
            <param name="binaryData">A buffer containing the resulting decoded byte[] data</param>
            <param name="ex">A exception indicating the error should an error be encountered while decoding the char array (only set when false is returned)</param>
            <returns>A value indicating if the decoding was successful, true for success, false for failure (in which case <paramref name="ex"/> will be set</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BinaryUtilities.TryHexDecode(System.Char[],System.Int32,System.Int32,System.Byte[]@,System.Exception@)">
            <summary>
            Attempts to parse an array of chars as a hex encoded string
            </summary>
            <param name="chars">The chars array to decode</param>
            <param name="offset">The offset to start decoding at within the <paramref name="chars"/> array</param>
            <param name="charLength">The number of chars within the <paramref name="chars"/> array to decode</param>
            <param name="binaryData">A buffer containing the resulting decoded byte[] data</param>
            <param name="ex">A exception indicating the error should an error be encountered while decoding the char array (only set when false is returned)</param>
            <returns>A value indicating if the decoding was successful, true for success, false for failure (in which case <paramref name="ex"/> will be set</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws if the input chars are not an even length or run off the end of the provided char array</exception>
            <exception cref="T:System.FormatException">Throws if the char array contains invalid chars</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BinaryUtilities.DecodeNibble(System.Char)">
            <summary>
            Converts a char to its hex 4 bit value (nibble)
            </summary>
            <param name="c">The char to convert valid values are 0-9 a-f A-F</param>
            <returns>The nibble value 0x00-0x0F</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">Throws if the char is an invalid</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BinaryUtilities.HexEncode(System.Byte[],System.Int32,System.Int32,System.String,System.String,System.String)">
            <summary>
            Converts a byte array into a HEX encoded string
            </summary>
            <param name="bin">The data array to hex encode</param>
            <param name="startOffset">The start offset within the <paramref name="bin"/> buffer</param>
            <param name="length">The number of bytes to encode within the <paramref name="bin"/> buffer</param>
            <param name="preHexChar">A string to be placed before each hex encoded byte</param>
            <param name="postHexChar">A string to be placed after each hex encoded byte</param>
            <param name="separator">A string to be placed between each hex encoded byte</param>
            <returns>The hex encoded string</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BinaryUtilities.HexEncode(System.Byte)">
            <summary>
            Hex encodes a byte
            </summary>
            <param name="value">The byte value to encode</param>
            <returns>The 2 char string that is the hex representation of the byte</returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.ConvertStringToXsd">
            <summary>
            Utility functions to convert strings to XSD types
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParse(LiquidTechnologies.XmlObjects.Attribution.XsdType,System.String,System.Object@)">
            <summary>
            Attempts to parse a string value as the XSD type <paramref name="type"/>
            </summary>
            <param name="type">The XSD type to convert the string to</param>
            <param name="stringValue">The string to convert</param>
            <param name="typedValue">The resulting value (type of object is specific to the <paramref name="type"/>)</param>
            <returns>true if the string value was successfully parsed.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseAnyType(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:anyType
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:anyType (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseAnySimpleType(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:anySimpleType
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:anySimpleType (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseAnyAtomicType(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:anyAtomicType
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:anyAtomicType (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseAnyURI(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:uri
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:uri (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseBase64Binary(System.String,System.Byte[]@)">
            <summary>
            Attempts to convert a string to an xs:base64
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:base64 value (represented as byte[])</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseBoolean(System.String,System.Boolean@)">
            <summary>
            Attempts to convert a string to an xs:boolean
            </summary>
            <param name="stringValue">The string value to parse (valid values are 0,1,true,false)</param>
            <param name="result">The resulting xs:boolean value (represented as bool)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseByte(System.String,System.SByte@)">
            <summary>
            Attempts to convert a string to an xs:byte
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:byte value (represented as byte)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseDate(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:date
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:date value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseDateTime(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:dateTime
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:dateTime value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseDateTimeStamp(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:dateTimeStamp
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:dateTimeStamp value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseDayTimeDuration(System.String,LiquidTechnologies.XmlObjects.LxDuration@)">
            <summary>
            Attempts to convert a string to an xs:dayTimeDuration
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:dayTimeDuration value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseDecimal(System.String,LiquidTechnologies.XmlObjects.BigDecimal@)">
            <summary>
            Attempts to convert a string to an xs:decimal
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:decimal value (represented as <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseDouble(System.String,System.Double@)">
            <summary>
            Attempts to convert a string to an xs:double
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:double value (represented as <see cref="T:System.Double"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseDuration(System.String,LiquidTechnologies.XmlObjects.LxDuration@)">
            <summary>
            Attempts to convert a string to an xs:duration
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:duration value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseENTITY(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:ENTITY
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:ENTITY (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseENTITIES(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:ENTITIES
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:ENTITIES (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseError(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:error
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:error (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseFloat(System.String,System.Single@)">
            <summary>
            Attempts to convert a string to an xs:float
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:float value (represented as <see cref="T:System.Single"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseGDay(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:gDay
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:gDay value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GDay"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseGMonth(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:gMonth
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:gMonth value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonth"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseGMonthDay(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:gMonthDay
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:gMonthDay value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonthDay"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseGYear(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:gYear
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:gYear value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYear"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseGYearMonth(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:gYearMonth
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:gYearMonth value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYearMonth"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseHexBinary(System.String,System.Byte[]@)">
            <summary>
            Attempts to convert a string to an xs:hex
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:hex value (represented as byte[])</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseID(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:ID
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:ID (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseIDREF(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:IDREF
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:IDREF (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseIDREFS(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:IDREFS
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:IDREFS (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseInt(System.String,System.Int32@)">
            <summary>
            Attempts to convert a string to an xs:int
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:int value (represented as an int)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseInteger(System.String,System.Numerics.BigInteger@)">
            <summary>
            Attempts to convert a string to an xs:integer
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:integer value (represented as an <see cref="T:System.Numerics.BigInteger"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseLanguage(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:language
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:language (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseLong(System.String,System.Int64@)">
            <summary>
            Attempts to convert a string to an xs:long
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:long value (represented as an long)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseName(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:name
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:name (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseNCName(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:NCName
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:NCName (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseNegativeInteger(System.String,System.Numerics.BigInteger@)">
            <summary>
            Attempts to convert a string to an xs:negativeInteger
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:negativeInteger value (represented as an <see cref="T:System.Numerics.BigInteger"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseNMTOKEN(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:NMTOKEN
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:NMTOKEN (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseNMTOKENS(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:NMTOKENS
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:NMTOKENS (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseNonNegativeInteger(System.String,System.Numerics.BigInteger@)">
            <summary>
            Attempts to convert a string to an xs:nonNegativeInteger
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:nonNegativeInteger value (represented as an <see cref="T:System.Numerics.BigInteger"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseNonPositiveInteger(System.String,System.Numerics.BigInteger@)">
            <summary>
            Attempts to convert a string to an xs:nonPositiveInteger
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:nonPositiveInteger value (represented as an <see cref="T:System.Numerics.BigInteger"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseNormalizedString(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:normalizedString
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:normalizedString (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParsePositiveInteger(System.String,System.Numerics.BigInteger@)">
            <summary>
            Attempts to convert a string to an xs:positiveIntege
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:positiveIntege value (represented as an <see cref="T:System.Numerics.BigInteger"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParsePrecisionDecimal(System.String,LiquidTechnologies.XmlObjects.BigDecimal@)">
            <summary>
            Attempts to convert a string to an xs:precisionDecimal
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:precisionDecimal value (represented as an <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseQName(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:QName
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:QName (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseShort(System.String,System.Int16@)">
            <summary>
            Attempts to convert a string to an xs:short
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:short value (represented as an <see cref="T:System.Int16"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseString(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:string
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:string (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseTime(System.String,LiquidTechnologies.XmlObjects.LxDateTime@)">
            <summary>
            Attempts to convert a string to an xs:time
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:time value (represented as an <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> of type <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Time"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseToken(System.String,System.String@)">
            <summary>
            Attempts to convert a string to an xs:token
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:token (string) value</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseYearMonthDuration(System.String,LiquidTechnologies.XmlObjects.LxDuration@)">
            <summary>
            Attempts to convert a string to an xs:yearMonthDuration
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:yearMonthDuration value (represented as <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseUnsignedByte(System.String,System.Byte@)">
            <summary>
            Attempts to convert a string to an xs:unsignedByte
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:unsignedByte value (represented as an <see cref="T:System.Byte"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseUnsignedInt(System.String,System.UInt32@)">
            <summary>
            Attempts to convert a string to an xs:unsignedInt
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:unsignedInt value (represented as an <see cref="T:System.UInt32"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseUnsignedLong(System.String,System.UInt64@)">
            <summary>
            Attempts to convert a string to an xs:unsignedLong
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:unsignedLong value (represented as an <see cref="T:System.UInt64"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertStringToXsd.TryParseUnsignedShort(System.String,System.UInt16@)">
            <summary>
            Attempts to convert a string to an xs:unsignedShort
            </summary>
            <param name="stringValue">The string value to parse</param>
            <param name="result">The resulting xs:unsignedShort value (represented as an <see cref="T:System.UInt16"/>)</param>
            <returns>true if the conversion was possible</returns>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.ConvertXsdValueToString.BoolRepresentation">
            <summary>
            Controls the way a boolean is represented in the generated XML
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertXsdValueToString.ConvertToString(LiquidTechnologies.XmlObjects.ParsedSimpleTypeData,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.String@,System.String@,LiquidTechnologies.XmlObjects.ConversionErrorType@)">
            <summary>
            Converts an object to a string of the type describes in <paramref name="metaData"/>
            </summary>
            <param name="metaData">A description of the target xsd type (including facets)</param>
            <param name="typedValue">The value to be converted (Must be the correct type given the <paramref name="metaData"/></param>
            <param name="settings"></param>
            <param name="stringValue">If successful the string value that represents the <paramref name="typedValue"/> as a xsd datatype text string.</param>
            <param name="errorMsg">On failure this describes the failure</param>
            <param name="errorType">On failure this describes the type of failure</param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ConvertXsdValueToString.ApplyDigitFacets(LiquidTechnologies.XmlObjects.ParsedSimpleTypeData,System.String,System.String@,System.String@,LiquidTechnologies.XmlObjects.ConversionErrorType@)">
            <summary>
            Adjusts the integer values to conform to the facets FractionDigits and TotalDigits.
            If this can be achieved by truncating the fractional part then true is returned. (<see cref="F:LiquidTechnologies.XmlObjects.ConversionErrorType.None"/>)
            If the facets can not be satisfied then false is returned (<see cref="F:LiquidTechnologies.XmlObjects.ConversionErrorType.FacetError"/>)
            </summary>
            <param name="metaData"></param>
            <param name="value"></param>
            <param name="stringValue"></param>
            <param name="errorMsg"></param>
            <param name="errorType"></param>
            <returns></returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.BoolRepresentationType">
            <summary>
            Indicates how xs:boolean types are rendered in the serialized XML data
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.BoolRepresentationType.TrueFalse">
            <summary>
            Indicates the bool representation in the XML will be "true" and "false"
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.BoolRepresentationType.OneZero">
            <summary>
            Indicates the bool representation in the XML will be "1" and "0"
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LookAheadMode">
            <summary>
            NOTE : ORDER IS IMPORTANT
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxCompositorAllReader">
             <summary>
            
             </summary>
             <remarks>
             The xs:all is actually quite simple, basically each element is read, if it matches a child type
             its processed as that. Matching rules still check named items first then xs:any matches
             then project forward into siblings, then match xs:openContent, finally treating it as 
             unprocessed (if enabled).
             </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorAllReader.IsAllowableNextElement(System.Xml.XmlQualifiedName,LiquidTechnologies.XmlObjects.LookAheadMode)">
            <summary>
            Determines if the given element is acceptable give the current state of the 
            reader
            </summary>
            <param name="elementQName"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxCompositorChoiceReader">
            <summary>
            A reader capable of reading the contents of an element
            This will take in all the compositor/alternative and openConent stuff.
            But will not directly do the work, specialit readers will be built to do
            the bits along the way.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorChoiceReader.IsAllowableNextElement(System.Xml.XmlQualifiedName,LiquidTechnologies.XmlObjects.LookAheadMode)">
            <summary>
            Determines if the given element is acceptable give the current state of the 
            reader
            </summary>
            <param name="elementQName"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxCompositorReader">
            <summary>
            A reader capable of reading the contents of an element
            This will take in all the compositor/alternative and openConent stuff.
            But will not directly do the work, specialit readers will be built to do
            the bits along the way.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorReader.ReadChildItems(System.Xml.XmlReader,System.Boolean)">
            <summary>
            Reads all the child items defined within the reader
            </summary>
            <param name="xmlReader"></param>
            <param name="isEmptyElement"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorReader.ReadCurrentItem(System.Xml.XmlReader)">
            <summary>
            Reads the current item at index _readPositionItemIndex
            It is assumed that the reader is valid for the data held in the xmlReader 
            (i.e. we have already checked the thing we are reading is the thing at index _readPositionItemIndex).
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorReader.ReadCompositor(System.Xml.XmlReader,System.Object,LiquidTechnologies.XmlObjects.Attribution.LxElementCompositorAttribute)">
            <summary>
            Finds the appropriate ClassInfoElementCompositor meta data.
            Creates a compositor class
            Reads the child elements into using a reader created from the meta data.
            </summary>
            <param name="xmlReader"></param>
            <param name="parentClass"></param>
            <param name="elementPropertyInfo"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorReader.ReadNamedElement(System.Xml.XmlReader,LiquidTechnologies.XmlObjects.Attribution.LxElementNamedAttribute)">
            <summary>
            Finds the appropriate ClassInfoElementCompositor meta data.
            Creates a compositor class
            Reads the child elements into using a reader created from the meta data.
            </summary>
            <param name="xmlReader"></param>
            <param name="elementPropertyInfo"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorReader.ReadOpenContent(System.Xml.XmlReader)">
            <summary>
            Reads the current child element as Open Content placing the value into the parentClass
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorReader.ReadUnprocessedElement(System.Xml.XmlReader)">
            <summary>
            Reads the current child element as Open Content placing the value into the parentClass
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorReader.EvaluteAlternatives(System.Xml.XmlReader,LiquidTechnologies.XmlObjects.Attribution.LxElementNamedAttribute)">
            <summary>
            Evaluates all the alternative xpath tests and returns the first matching result
            </summary>
            <param name="xmlReader"></param>
            <param name="elementPropertyInfo"></param>
            <returns>null if no test evaluated to true - which is an error</returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxCompositorSequenceReader">
            <summary>
            A reader capable of reading the contents of an element
            This will take in all the compositor/alternative and openConent stuff.
            But will not directly do the work, specialit readers will be built to do
            the bits along the way.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorSequenceReader.IsAllowableNextElement(System.Xml.XmlQualifiedName,LiquidTechnologies.XmlObjects.LookAheadMode)">
            <summary>
            Determines if the given element is acceptable give the current state of the 
            reader
            </summary>
            <param name="elementQName"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorSequenceReader.ReadChildItems(System.Xml.XmlReader,System.Boolean)">
            <summary>
            
            </summary>
            <paramref name="xmlReader"></paramref>
            <paramref name="isEmptyElement">
            positioned within the element (after the start tag or between the child elements).
            OR ... if this is an empty element.
            </paramref>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorSequenceReader.CanDescendantsReadAsElementOrAny(System.Xml.XmlQualifiedName)">
            <summary>
            true if the parent (or its parent etc) can read the element as xs:any or a specific element
            </summary>
            <param name="elementQName"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorSequenceReader.CanDescendantsReadAsOpenContentAnyOrElement(System.Xml.XmlQualifiedName)">
            <summary>
            true if the parent (or its parent etc) can read the element as open content or any element or a specific element.
            </summary>
            <param name="elementQName"></param>
            <returns></returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxCompositorSimpleReader">
            <summary>
            Represents our 'Simple' compositor (which has no parallel in the XSD standard)
            </summary>
            <remarks>
            We have <see cref="T:LiquidTechnologies.XmlObjects.LxCompositorReader"/> classes to represent xs:all, xs:choice and xs:sequence,
            this class represents our 'simple' structurings. 
            The simple structure basically is a flat structure containing all the possible child elements
            at the base level (represented by this).
            As such it should only contain xs:element (or xs:any), it should NOT contain compositors.
            The represents a xs:all is actually quite simple, basically each element is read, if it matches a child type
            its processed as that. Matching rules still check named items first then xs:any matches
            then project forward into siblings, then match xs:openContent, finally treating it as 
            unprocessed (if enabled).
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxCompositorSimpleReader.IsAllowableNextElement(System.Xml.XmlQualifiedName,LiquidTechnologies.XmlObjects.LookAheadMode)">
            <summary>
            Determines if the given element is acceptable give the current state of the 
            reader
            </summary>
            <param name="elementQName"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxElementReader">
            <summary>
            A reader capable of reading the contents of an element
            This will take in all the compositor/alternative and openConent stuff.
            But will not directly do the work, speciality readers will be built to do
            the bits along the way.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxElementReader.ProcessedAttributes">
            <summary>
            A list of all the attributes processed so far
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxElementReader.Read(System.Xml.XmlReader)">
            <summary>
            Reads all the attributes and child elements in the current Xml Element
            The xmlReader must be positioned at the start of an element.
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxElementReader.ReadElementText(System.Xml.XmlReader,System.Xml.XmlQualifiedName,System.Boolean)">
            <summary>
            Reads the content of the element and stores the text in the property described by ValueAttribute
            Any element encountered are pushed into the openContent handler or the UnprocessedElements handler 
            (From what I can tell its only allowed to contain other elements if its mixed).
            </summary>
            <param name="xmlReader"></param>
            <param name="containingElementName"></param>
            <param name="isEmptyElement"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxElementReader.ReadAttribute(System.Xml.XmlReader)">
            <summary>
            Reads the current attribute into the parentClass.
            Updates the ProcessedAttributes &amp; RequiredAttributes collections to reflect the work done.
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxElementReader.ReadOpenContent(System.Xml.XmlReader)">
            <summary>
            Reads the current child element as Open Content placing the value into the parentClass
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxElementReader.ReadUnprocessedElement(System.Xml.XmlReader)">
            <summary>
            Reads the current child element as Open Content placing the value into the parentClass
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxReader.IsAllowableNextElement(System.Xml.XmlQualifiedName,LiquidTechnologies.XmlObjects.LookAheadMode)">
            <summary>
            Determines if the given element is acceptable give the current state of the 
            reader
            </summary>
            <param name="elementQName"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxReader.ReadAnyElement(System.Xml.XmlReader,LiquidTechnologies.XmlObjects.Attribution.LxElementAnyAttribute)">
            <summary>
            Finds the appropriate ClassInfoElementCompositor meta data.
            Creates a compositor class
            Reads the child elements into using a reader created from the meta data.
            </summary>
            <param name="xmlReader"></param>
            <param name="elementPropertyInfo"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxReader.ReadOpenContent(System.Xml.XmlReader)">
            <summary>
            Reads the current child element as Open Content placing the value into the parentClass
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxReader.ReadUnprocessedElement(System.Xml.XmlReader)">
            <summary>
            Reads the current child element as Open Content placing the value into the parentClass
            </summary>
            <param name="xmlReader"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxReader.ReadElementText(System.Xml.XmlReader,System.Collections.Generic.IEnumerable{System.Xml.Linq.XElement}@)">
            <summary>
            Reads the text content of the element,
            if the content is mixed, then all the text is concatenated.
            Any inner element found are returned via the innerElements out param
            </summary>
            <param name="xmlReader">Should be on the first nodeType within the element</param>
            <param name="innerElements"></param>
            <returns>true if it returned on a start tag, else false</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxReader.MoveToNextChildElement(System.Xml.XmlReader)">
            <summary>
            Reads past any crap until it finds an element start tag. 
            If its already on an element start tag then it does nothing.
            If it hits an end tag then it stops and returns false
            </summary>
            <param name="xmlReader"></param>
            <returns>true if it returned on a start tag, else false</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxReader.MoveToClosingElementTag(System.Xml.XmlReader)">
            <summary>
            Reads past any crap until it finds an element start tag. 
            If its already on an element start tag then it does nothing.
            If it hits an end tag then it stops and returns false
            </summary>
            <param name="xmlReader"></param>
            <returns>true if it returned on a start tag, else false</returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxReaderSettings">
            <summary>
            Provides settings that affect how the reading/de-serialization of an XML document is
            handled.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxReaderSettings.#ctor">
            <summary>
            Creates a new <see cref="T:LiquidTechnologies.XmlObjects.LxReaderSettings"/>
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxReaderSettings.ErrorHandler">
            <summary>
            The error handler callback that is called when an error occurs during the de-serialization process
            </summary>
            <exception cref="T:System.ArgumentNullException">If its set to null</exception>
            <remarks>
            The Default error handler throws a <see cref="T:LiquidTechnologies.XmlObjects.LxSerializationException"/> for errors and ignores warnings
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxReaderSettings.TypeResolver">
            <summary>
            A function that will resolve any ambiguity if there are multiple types that could be used to 
            de-serialize a give XML Element
            </summary>
            <exception cref="T:System.ArgumentNullException">If its set to null</exception>
            <remarks>
            The Default handler throws.
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxReaderSettings.DefaultTimeZone">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.ILxSettings.DefaultTimeZone"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxReaderSettings.IgnoreXmlnsAttributes">
            <summary>
            Causes xmlns (namespace declarations) to processed, but then ignored (not stored in the object model). <br/>
            This means they not appear when the object is serialized again unless they required.<br/>
            (default false)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxReaderSettings.IgnoreSchemaLocationAttributes">
            <summary>
            Causes xsi:noNamespaceSchemaLocation and xsi:schemaLocation attributes to be ignored 
            (not stored in the object model), and do not raise warnings or errors. <br/>
            This means they do not appear when the object is serialized again.<br/>
            (default true)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxReaderSettings.AllowableExternalNamespaces">
            <summary>
            A list of namespaces. Any unexpected attributes in these namespaces are ignored.
            </summary>
            <remarks>
             By default attributes in the following namespaces ("http://www.w3.org/2000/xmlns/", 
             "http://www.w3.org/2001/XMLSchema-instance") are ignored if they are not processed;
            </remarks>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDeserializerErrorHandler">
            <summary>
            A callback error handler to deal with errors that occur during the de-serialization of XML data 
            </summary>
            <param name="msg">The error message describing the issue</param>
            <param name="severity">The severity of the error </param>
            <param name="errorCode">The error code providing detail about the issue</param>
            <param name="location">The location of the issue in the source XML document</param>
            <param name="targetObject">The object the data is being de-serialized into (a Liquid XML Objects generated class)</param>
            <remarks>The handler either choose to ignore the error or  throw an exception to halt the de-serialization process.</remarks>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDeserializerTypeResolver">
            <summary>
            A function that will resolve any ambiguity if there are multiple types that could be used to 
            de-serialize a give XML Element
            </summary>
            <param name="candidateTypes">All the types that are candidates for representing the XML element</param>
            <param name="elementQName">The qualified name of an element</param>
            <param name="complexTypeQName">The qualified name of an elements xsi:type (can be null)</param>
            <param name="assignableType">The returned type must be assignable to this type</param>
            <return>The Type that will be used to deserialize the element</return>
            <remarks>
            The handler should either return one of the types in <paramref name="candidateTypes"/> 
            or throw an exception to halt the de-serialization process.
            </remarks>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.TypeDeserializationOrderComparer">
            <summary>
            Orders the XsdType in a union so they are read in a sensible order (stops [0, 1, 2] turning into [false, true, 2]).
            
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.InvalidEnumArgumentException">
            <summary>
            .Net Standard Polyfill for System.ComponentModel.InvalidEnumArgumentException
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.InvalidEnumArgumentException.#ctor(System.String,System.Int32,System.Type)">
            <summary>
               Initializes a new instance of the <see cref='T:LiquidTechnologies.XmlObjects.InvalidEnumArgumentException'/> class with a 
               message generated from the argument, invalid value, and enumeration
               class.
            </summary>
            <param name="paramName">The name of the parameter that is invalid</param>
            <param name="paramValue">The invalid enumeration integer value</param>
            <param name="enumType">The type of the enumeration</param>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.InvalidEnumArgumentException.ParamValue">
            <summary>
            The invalid enumeration integer value
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.InvalidEnumArgumentException.EnumType">
            <summary>
            The type of the enumeration
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.InvalidEnumArgumentException.Message">
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxException">
            <summary>
            Base class for all Liquid XML Objects Exceptions
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxValidationException">
            <summary>
            Base class for validation exceptions
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxValidationException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxValidationException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxValidationException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxValidationException.#ctor(System.String,LiquidTechnologies.XmlObjects.LxErrorSeverity,LiquidTechnologies.XmlObjects.LxErrorCode,LiquidTechnologies.XmlObjects.TextLocation)">
            <summary>
            Constructs a LxValidationException 
            </summary>
            <param name="msg">The error message describing the issue</param>
            <param name="severity">The severity of the error</param>
            <param name="errorCode">The error code providing detail about the issue</param>
            <param name="location">may be null</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxValidationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxValidationException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxValidationException.Severity">
            <summary>
            The severity of the serialization error
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxValidationException.ErrorCode">
            <summary>
            The error code best describing the serialization error
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxValidationException.Location">
            <summary>
            The location of the serialization error within the source file
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxSerializationException">
            <summary>
            Throw during Serialization and DeSerialization when an error occurs
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializationException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializationException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializationException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializationException.#ctor(System.String,LiquidTechnologies.XmlObjects.LxErrorSeverity,LiquidTechnologies.XmlObjects.LxErrorCode,LiquidTechnologies.XmlObjects.TextLocation,System.Object)">
            <summary>
            Constructs a LxSerializationException
            </summary>
            <param name="msg">The error message describing the issue</param>
            <param name="severity">The severity of the error</param>
            <param name="errorCode">The error code providing detail about the issue</param>
            <param name="location">may be null</param>        
            <param name="targetObject">The object that the error occurred on</param>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxSerializationException.TargetObject">
            <summary>
            The object that the error occurred on
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">
            <summary>
            Throw when a value if not valid for the to type (i.e. badly formatted date time)
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidValueException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidValueException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidValueException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidValueException.#ctor(System.String,LiquidTechnologies.XmlObjects.LxErrorSeverity,LiquidTechnologies.XmlObjects.LxErrorCode,LiquidTechnologies.XmlObjects.TextLocation)">
            <summary>
            Constructs a LxSerializationException
            </summary>
            <param name="msg">The error message describing the issue</param>
            <param name="severity">The severity of the error</param>
            <param name="errorCode">The error code providing detail about the issue</param>
            <param name="location">may be null</param>      
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidValueException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDataInFileException">
            <summary>
            Throw when a value if not valid for the to type (i.e. badly formatted date time)
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDataInFileException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDataInFileException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDataInFileException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDataInFileException.#ctor(System.String,LiquidTechnologies.XmlObjects.LxErrorSeverity,LiquidTechnologies.XmlObjects.LxErrorCode,System.String,LiquidTechnologies.XmlObjects.TextLocation)">
            <summary>
            Constructs a LxSerializationException
            </summary>
            <param name="msg">The error message describing the issue</param>
            <param name="severity">The severity of the error</param>
            <param name="errorCode">The error code providing detail about the issue</param>
            <param name="filename">The error the file occurred in</param>
            <param name="location">may be null</param>      
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDataInFileException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDataInFileException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDataInFileException.Filename">
            <summary>
            The error the file occurred in
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxInvalidStateException">
            <summary>
            Throw when serializer is in an unexpected state causing it to fail to read or write a document
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidStateException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidStateException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidStateException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidStateException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc cref="M:System.Exception.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDesignTimeException">
            <summary>
            Base class for errors that indicate an issue with the design time data (attributed classes)
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDesignTimeException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDesignTimeException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDesignTimeException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDesignTimeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxLicenseException">
            <summary>
            Throw when a value if not valid for the to type (i.e. badly formatted date time)
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLicenseException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLicenseException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLicenseException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLicenseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxInvalidAttributionException">
            <summary>
            Thrown if the attributes on a class/property contain errors
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidAttributionException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidAttributionException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidAttributionException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidAttributionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxInvalidDesignTimeDataException">
            <summary>
            Thrown when the value or type of a property is not what is expected
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidDesignTimeDataException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidDesignTimeDataException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidDesignTimeDataException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxInvalidDesignTimeDataException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxApplicationLogicException">
            <summary>
            Indicates a problem with the Liquid XML Objects Runtime, please report this issue to 
            support https://www.liquid-technologies.com/create-support-ticket
            </summary>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxApplicationLogicException.#ctor">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxApplicationLogicException.#ctor(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxApplicationLogicException.#ctor(System.String,System.Exception)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxApplicationLogicException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.ILxSettings">
            <summary>
            Settings common to reading and writing
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.ILxSettings.DefaultTimeZone">
            <summary>
            Determines how dates/times without explicit timezone information should be treated.<br/>
            Default is UTC
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.IRegExParser">
            <summary>
            The interface that must be supported by any external regex implementation
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.IRegExParser.IsMatch(System.String)">
            <summary>
             Indicates whether the regular expression specified in the System.Text.RegularExpressions.Regex
             constructor finds a match in a specified input string.
            </summary>
            <param name="input"> The string to search for a match.</param>
            <returns>true if the regular expression finds a match; otherwise, false.</returns>
            <exception cref="T:System.ArgumentNullException">input is null.</exception>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.IRegExParser.Pattern">
            <summary>
            The regular expression pattern
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Serializer">
            <summary>
            A base implementation for all the serialization classes.
            Holds the loaded metat data for the XML schema.
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.JsonReaderDefaultHandler">
            <summary>
            Default handler for JsonTextReader, calls through to external handler
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.JsonReaderToXmlHandler">
            <summary>
            Writes JSON data into XmlTextWriter
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.JsonTextReader.Read">
            <summary>
            Reads and validates the entire JSON document and calls back through the IJsonHandler
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.JsonTextReader.ReadNextChar(System.Boolean)">
            <summary>
            Read the next character from the TextRead and optionally skip over any comments.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.JsonTextReader.ReadValue(System.Int32)">
            <summary>
            Main reader method.
            NOTE: As some items (e.g. Number) can only tell they have finished when the character AFTER has been read, to make parsing easier we assume ALL items
            always read the character after, e.g. ReadObject reads the character after '}'.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.JsonTextReader.ReadNumber">
            <summary>
            Reads a JSON number and validates it against JSON spec
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LjReaderSettings">
            <summary>
            Provides settings that affect how the reading/de-serialization of a JSON document is handled.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjReaderSettings.SupportRoundtrip">
            <summary>
            The mode used when serializing JSON data to enable the JSON document to be read back into the Liquid XML Objects model. See <see cref="T:LiquidTechnologies.XmlObjects.JsonRoundTrip"/>.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjReaderSettings.RootElementName">
            <summary>
            Optional name used as a root element in serializing JSON data.
            Sometimes JSON data may produce multiple root level elements which would produce an invalid XML document.
            This optional value allows you to specify a root level element which the generator will use as the single root of the XML document.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjReaderSettings.AllowComments">
            <summary>
            Allows single and multi-line comments when serializing JSON data. Default = true.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.JsonTextWriter.PadAndWriteValue(System.String)">
            <summary>
            Write out the value which represents text data (i.e. an actual data value not a name)
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LjWriterSettings">
            <summary>
            Provides settings that affect how the writing/serialization of a Liquid XML Objects attributed class to a JSON document.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjWriterSettings.SupportRoundtrip">
            <summary>
            The mode used when serializing JSON data to enable the JSON document to be read back into the Liquid XML Objects model. See <see cref="T:LiquidTechnologies.XmlObjects.JsonRoundTrip"/>.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjWriterSettings.NewLineChars">
            <summary>
            Gets or sets the character string to use for line breaks.The default is \r\n (carriage return, new line).
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjWriterSettings.Indent">
            <summary>
            Gets or sets a value indicating whether to indent items. The default is True.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjWriterSettings.IndentChars">
            <summary>
            Gets or sets the character string to use when indenting. This setting is used when Indent property is set to true. The default is two spaces.
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LicenseTermsType">
            <summary>
            The basis the code is licensed under
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LicenseTermsType.FullLicense">
            <summary>
            A license has been purchased, see 
            <externalLink>
                <linkText>EULA</linkText>
                <linkAlternateText>Liquid XML Objects EULA</linkAlternateText>
                <linkUri>https://www.liquid-technologies.com/xml-objects/eula</linkUri>
            </externalLink>
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LicenseTermsType.Educational">
            <summary>
            An educational license (for non-commercial use), see
            <externalLink>
                <linkText>EULA</linkText>
                <linkAlternateText>Liquid XML Objects EULA</linkAlternateText>
                <linkUri>https://www.liquid-technologies.com/xml-objects/eula</linkUri>
            </externalLink>
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LicenseTermsType.CommunityEdition">
            <summary>
            Community license - free but has limits on the size of the source schema, see
            <externalLink>
                <linkText>EULA</linkText>
                <linkAlternateText>Liquid XML Objects EULA</linkAlternateText>
                <linkUri>https://www.liquid-technologies.com/xml-objects/eula</linkUri>
            </externalLink>
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LicenseTermsType.Sample">
            <summary>
            Sample license - for evaluation purposes, see
            <externalLink>
                <linkText>Licensing Sample Projects</linkText>
                <linkAlternateText>Licensing Sample Projects</linkAlternateText>
                <linkUri>https://www.liquid-technologies.com/reference/xml-objects/library/licensing</linkUri>
            </externalLink> 
            to upgrade the license to a <see cref="F:LiquidTechnologies.XmlObjects.LicenseTermsType.FullLicense"/>.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LicenseTermsType.Trial">
            <summary>
            Trail license - fully functional, time limited license for testing an evaluation.
            <externalLink>
                <linkText>EULA</linkText>
                <linkAlternateText>Liquid XML Objects EULA</linkAlternateText>
                <linkUri>https://www.liquid-technologies.com/xml-objects/eula</linkUri>
            </externalLink>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.JsonRoundTrip">
            <summary>
            The mode used when serializing JSON data to enable the JSON document to be read back into the Liquid XML Objects model.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.JsonRoundTrip.None">
            <summary>
            None - JSON contains no additional data. The JSON document is unlikely to be readable into the Liquid XML Objects model.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.JsonRoundTrip.Basic">
            <summary>
            Basic - JSON contains additional data for Attribute and Element Text support and is suitable for a simple data model.
                    Attributes are prefixed with '@' and Element Text is named '#text'.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.JsonRoundTrip.Full">
            <summary>
            Full - JSON contains additional data for Attribute, Element Text, Namespace and Type support and is suitable for more complex data models.
                   Attributes are prefixed with '@' and Element Text is named '#text'. Namespace prefix are written on each node.
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LjSerializer`1">
            <summary>
            A generic wrapper around the <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/> class.
            </summary>
            <typeparam name="T">The type to be serialized/de-serialized</typeparam>
            <remarks>
            It is possible to define several <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer`1"/> classes (with different types) 
            based on the same underlying <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/> instance.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.#ctor(System.Reflection.Assembly[])">
            <summary>
            Constructor (creates a new <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/> instance internally)
            </summary>
            <param name="assembliesToScan">
            An optional list of assemblies to search for Liquid XML Objects serialization classes.<br/>
            If no assemblies are provided all loaded assemblies are included.<br/>
            The assembly containing the type <typeparamref name="T"/> is always included.<br/>
            <br/>
            NOTE: On .Net Standard 1.6 and below, you must explicitly supply a list any additional 
            assemblies (it only automatically adds the assembly containing <typeparamref name="T"/>).
            </param>
            <remarks>
            The creation of the internal <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/> class is quite expensive, 
            if multiple <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer`1"/> classes need to be constructed then for 
            performance reasons it may be advantageous to explicitly create an instance
            of <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/> and use the constructor <see cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.#ctor(LiquidTechnologies.XmlObjects.Serializer)"/>.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.#ctor(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Constructor (using an existing <see cref="T:LiquidTechnologies.XmlObjects.Serializer"/> instance)
            </summary>
            <param name="baseSerializer">An existing <see cref="T:LiquidTechnologies.XmlObjects.Serializer"/></param>
            <remarks>
            Allows the serializer to be intialized from an existing <see cref="T:LiquidTechnologies.XmlObjects.Serializer"/> instance (i.e. a <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer"/> or <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/> instance). 
            The creation of a new serializer can be quite expensive as it needs to scan for LXO generated objects. 
            So for performance reasons it may make sense to only  perform this work once.
            
            The assembly containing the type <typeparamref name="T"/> is automatically added to <paramref name="baseSerializer"/>.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.String,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.String,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.IO.Stream,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.IO.TextReader,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.String,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <param name="filename">The file the XML data will be read from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <param name="stream">The <see cref="T:System.IO.Stream"/> the data will be read from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <summary>
            Creates an instance of <typeparamref name="T"/> from the data in the <paramref name="textReader"/>
            </summary>
            <returns>A new instance of <typeparamref name="T"/> loaded with data from the <paramref name="textReader"/></returns>
            <exception cref="T:System.InvalidCastException">If the object created from the XML Data is not castable to the type in <typeparamref name="T"/>
            (this is typically the case if an the XML file contains the wrong root element for <typeparamref name="T"/>).</exception>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxException">General errors</exception>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Serialize(System.String,`0,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes a class of type <typeparamref name="T"/> to file.
            </summary>
            <param name="filename">The file to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Serialize(System.IO.TextWriter,`0,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Serialize(System.IO.Stream,`0,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes a class of type <typeparamref name="T"/> to an <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The stream to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Serialize(System.IO.TextWriter,`0,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Serialize(System.IO.TextWriter,`0,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes a class of type <typeparamref name="T"/> to an <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="textWriter">The <see cref="T:System.IO.TextWriter"/> to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer`1.Serialize(System.IO.TextWriter,`0,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LjSerializer">
            <summary>
            Performs serialization an de-serialization of classes marked up with the 
            Liquid XML Objects serialization attributes.
            </summary>
            <remarks>
            The LjSerializer class can be quite expensive to create as it needs to scan
            assemblies for classes marked up with the Liquid XML Objects serialization attributes.
            For this reason is may be advantageous to cache a copy of the object and re-use
            it rather than re-creating it on demand.
            
            The class is currently NOT thread safe. An instance of LjSerializer should be
            created for each thread that uses it.
            </remarks>
            <example>
            Simple Reader Example
            <code>
            LjSerializer serializer = new LjSerializer(typeof(MyElementClass).Assembly);
            using (FileStream fs = File.Create("MyJsonFile.json"))
            {
                MyElementClass elmCls = (MyElementClass)serializer.Deserialize(fs);
                ...
            }
            </code>
            
            Simple Writer Example
            <code>
            MyElementClass elmCls = ...;
            JsonWriterSettings xws = new JsonWriterSettings() { Indent = true };
            LjWriterSettings lxs = new LjWriterSettings { };
            
            using (FileStream fs = File.Create("MyJsonFile.json"))
            {
                serializer.Serialize(fs, lxs, elmCls);
            }
            </code>
            </example>
            <seealso cref="T:LiquidTechnologies.XmlObjects.LjSerializer`1"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjSerializer.Version">
            <summary>
            The version of the runtime - must match the version in the generated code
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LjSerializer.NugetVersion">
            <summary>
            The version of the Nuget the LXO runtime is contained within. A string in the form X.X.X
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.#ctor(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Constructs an LjSerializer, required for serializing and de-serializing Liquid XML Objects attributed classes. Uses the
            type information registered with the <paramref name="serializer"/>
            </summary>
            <param name="serializer">
            An existing serializer with type information already registered. This type information will then be available to this serializer.
            </param>
            <remarks>
            Allows the serializer to be intialized from an existing <see cref="T:LiquidTechnologies.XmlObjects.Serializer"/> instance (typically this would be
            a serializer of a different type i.e. <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/>). The creation of a new serializer can be quite 
            expensive as it needs to scan for LXO generated objects. So for performance reasons it may make sense to only 
            perform this work once.
            
            This class uses the <paramref name="serializer"/> object, so any assemblies registered against this object using the <see cref="M:LiquidTechnologies.XmlObjects.LjSerializer.RegisterAssembly(System.Reflection.Assembly,System.Predicate{System.Type})"/>,
            will also be registered against the <paramref name="serializer"/> object.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.#ctor(System.Reflection.Assembly[])">
            <summary>
            Constructs an LjSerializer, required for serializing and de-serializing Liquid XML Objects attributed classes.
            </summary>
            <param name="assembliesToScan">
            An optional list of assemblies to scan for Liquid XML Objects serialization classes.<br/>
            If no assemblies are provided then ALL assemblies are scanned.<br/>
            </param>
            <remarks>
            Additional assemblies can be added to the scan list later using the <see cref="M:LiquidTechnologies.XmlObjects.LjSerializer.RegisterAssembly(System.Reflection.Assembly,System.Predicate{System.Type})"/> method.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.#ctor(System.Predicate{System.Type},System.Reflection.Assembly[])">
            <summary>
            Constructs an LjSerializer, required for serializing and de-serializing Liquid XML Objects attributed classes.
            </summary>
            <param name="assembliesToScan">
            An optional list of assemblies to scan for Liquid XML Objects serialization classes.<br/>
            If no assemblies are provided then ALL assemblies are scanned.<br/>
            </param>
            <param name="classRegistrationFilter">
            Makes it possible to select which classes are registered with the serializer (the function should return true to register the class).
            </param>
            <remarks>
            Additional assemblies can be added to the scan list later using the <see cref="M:LiquidTechnologies.XmlObjects.LjSerializer.RegisterAssembly(System.Reflection.Assembly,System.Predicate{System.Type})"/> method.
            </remarks>
            <example>
            <![CDATA[
            var companySerializer = new LjSerializer(type => type.Namespace.StartsWith("MyProject.MyCompanyXSD."));
            var companyEmployeeSerializer = new LjSerializer<MyProject.MyCompanyXSD.EmployeeElm>(companySerializer);
            var companyEmployee = companyEmployeeSerializer.Deserialize(@"C:\CompanyEmployee.xml");
            ]]></example>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Serialize(System.String,System.Object,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)">
            <param name="filename">The stream to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Serialize(System.IO.TextWriter,System.Object,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Serialize(System.IO.Stream,System.Object,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)">
            <param name="stream">The stream to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Serialize(System.IO.TextWriter,System.Object,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Serialize(System.IO.TextWriter,System.Object,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)">
            <param name="textWriter">The xml writer to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Serialize(LiquidTechnologies.XmlObjects.JsonTextWriter,System.Object,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)"/>
            <remarks>
            The XML data written is indented and encoded using UTF-8.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Serialize(LiquidTechnologies.XmlObjects.JsonTextWriter,System.Object,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes an Liquid XML Objects attributed class to an <see cref="T:LiquidTechnologies.XmlObjects.JsonTextWriter"/>.
            </summary>
            <param name="jsonWriter">The <see cref="T:LiquidTechnologies.XmlObjects.JsonTextWriter"/> to write the XML data to</param>
            <param name="elementObj">The Liquid XML Objects attributed class to serialize</param>
            <param name="settings">The Liquid XML Objects settings to control the serialization, default configuration is used if null</param>
            <param name="elementName">The name of the root XML element. Only required if the <paramref name="elementObj"/> is a complexType (attributed with <see cref="T:LiquidTechnologies.XmlObjects.Attribution.LxComplexTypeDefinitionAttribute"/>).</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.String,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.String,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.String,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <param name="filename">The file the XML data will be read from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.Stream,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <param name="stream">The <see cref="T:System.IO.Stream"/> the data will be read from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.TextReader,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LjReaderSettings)">
            <summary>
            De-serializes an JSON document, creating a class populated with the data from the TextReader.
            </summary>
            <param name="textReader">The <see cref="T:System.IO.TextReader"/> to read the JSON data from</param>
            <param name="rootElementQName">
            The qualified name of the root element (useful when the root element contains an xsi:type attribute 
            and the class returned is attributed with <see cref="T:LiquidTechnologies.XmlObjects.Attribution.LxComplexTypeDefinitionAttribute"/>), in which case 
            the value of <paramref name="rootElementQName"/> will be needed in <see cref="M:LiquidTechnologies.XmlObjects.LjSerializer.Serialize(LiquidTechnologies.XmlObjects.JsonTextWriter,System.Object,LiquidTechnologies.XmlObjects.LjWriterSettings,System.Xml.XmlQualifiedName)">Serialize</see> 
            </param>
            <param name="settings">A settings to control how the data is de-serialized</param>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxException">General errors</exception>
            <returns>The de-serialized object</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LjSerializer.RegisterAssembly(System.Reflection.Assembly,System.Predicate{System.Type})">
            <summary>
            Registers an assembly and all the Liquid XML Objects attributed classes within it with the serializer.
            </summary>
            <param name="assembly">The assembly to register</param>
            <remarks>
            The assembly is already registered then it is ignored and no action is taken.</remarks>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxConstants">
            <summary>
            Lx Constants
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxConstants.Unbounded">
            <summary>
            An integer value to indicate that the range is unlimited (to infinity).
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDiagnostics">
            <exclude />
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxErrorCode">
            <summary>
            XML Serialization error codes 
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.MissingAttribute">
            <summary>
            A required attribute is missing
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.UnknownAttribute">
            <summary>
            When an unexpected attribute was found when reading XML data
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.DuplicateAttribute">
            <summary>
            An attribute with the same name (and namespace) was read from an XML element.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.MissingElement">
            <summary>
            When reading or writing an XML file a required element is missing.
            (occurs when the number of element read is less than minOccurs).
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.AdditionalElement">
            <summary>
            Occurs when to many XML elements are written.
            (Occurs when the number of elements written is greater than maxOccurs)
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.UnknownElement">
            <summary>
            When an unexpected element was found when reading XML data
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.UnexpectedToken">
            <summary>
            Occurs when an unexpected character is encountered while reading 
            an XML file. Typically a result of badly formed XML data.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.InvalidComplexType">
            <summary>
            Occurs when the xsi:type value read could not be found or is not
            valid for the current location.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.InvalidValue">
            <summary>
            Value conversion error
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.FacetFailed">
            <summary>
            A value failed a facet rule
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.ExtraChoiceValues">
            <summary>
            Elements were read that provide multiple values for a choice (an xs:choice can only contain a single valid option)
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.NameMissmatch">
            <summary>
            Occurs when the writer encounters an element which is not consistent with the 
            xsd type data. In these cases the xsd type data is used.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.InvalidNameOrNamespace">
            <summary>
            Occurs when the writer encounters an element which is not valid in the given context
            because of its name. This is typically an xs:any or xs:openContent that contains 
            an element that is not allowed due to the xsd rules imposed on it.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.UnexpectedXsiNil">
            <summary>
            Unexpected xsi:nil attribute has been encountered in the XML, where the schema does not allow it
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.AlternativeXsError">
            <summary>
            The result of an alternative 'Test' resulted in an xs:error
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorCode.NoValidAlternative">
            <summary>
            None of the alternative tests were successful
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxErrorSeverity">
            <summary>
            Indicates the severity of an error
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorSeverity.Warning">
            <summary>
            A warning message
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxErrorSeverity.Error">
            <summary>
            An error message
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.ResolveName(System.Xml.XmlReader,System.String)">
            <summary>
            Converts a name in the form xs:element into an XmlQualifiedName
            </summary>
            <param name="reader"></param>
            <param name="qname"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.GetContainedPropertyType(System.Reflection.PropertyInfo)">
            <summary>
            Gets the actual type of the property
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
            <example><![CDATA[
            List<int> would return int
            LxNullable<int> would return int
            List<LxNullable<int>> would return int
            ]]></example>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.GetContainedPropertyType(System.Type)">
            <summary>
            Gets the actual type of the property
            </summary>
            <param name="outerType"></param>
            <returns></returns>
            <example><![CDATA[
            List<int> would return int
            LxNullable<int> would return int
            List<LxNullable<int>> would return int
            ]]></example>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.IsXmlnsDecl(System.Xml.Linq.XName)">
            <summary>
            Checks if its a namespace in the form xmlns="..." or xmlns:xx="..."
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.GetSafeDisplableValue(System.String)">
            <summary>
            Gets a value that can be displayed in an error msg etc. 
            It truncates the value so not to much is displayed if its massive.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.IsCollectionType(System.Type)">
            <summary>
            true if the type is an IList&lt;&gt;
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.GetCollectionType(System.Type)">
            <summary>
            Gets the Nillable contained type (it its Nullable) otherwise it returns null
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.IsNullableType(System.Type)">
            <summary>
            Gets the Nullable contained type (it its Nullable) otherwise it returns null
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.GetNullableType(System.Type)">
            <summary>
            Gets the Nullable contained type (it its Nullable) otherwise it returns null
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.IsNillableType(System.Type)">
            <summary>
            Gets the Nillable contained type (it its Nullable) otherwise it returns null
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.GetNillableType(System.Type)">
            <summary>
            Gets the Nillable contained type (it its Nullable) otherwise it returns null
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxExtensions.WriteAttributeSafeString(System.Xml.XmlWriter,System.String,System.String,System.String,LiquidTechnologies.XmlObjects.Attribution.XsdType)">
            <summary>
            Writes an attribute. If the attribute is a namespace declaration and
            it conflicts with an existing declaration then it is ignored
            </summary>
            <param name="xmlWriter"></param>
            <param name="attributeName"></param>
            <param name="attributeNamespaceUri"></param>
            <param name="value"></param>
            <param name="type"></param>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxLinqExtensions">
            <summary>
            Linq style extensions for the generated Liquid XML Objects classes
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.AsEnumerable``1(``0,System.Boolean)">
            <summary>
            Converts an object T in to an IEnumerable&lt;T&gt;
            </summary>
            <typeparam name="T">The type to convert to a sequence</typeparam>
            <param name="item">The item to place in the sequence</param>
            <param name="ignoreNull">When true if <paramref name="item"/> is null then an empty sequence is returned</param>
            <returns>a sequence containing the <paramref name="item"/> value (on an empty sequence if <paramref name="item"/> is null and <paramref name="ignoreNull"/> is true).</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.AsEnumerable``1(System.Nullable{``0})">
            <summary>
            Converts an object Nullable&lt;T&gt; in to an IEnumerable&lt;T&gt;
            </summary>
            <typeparam name="T">The type to convert to a sequence</typeparam>
            <param name="item">The item to place in the sequence</param>
            <returns>A sequence containing the <paramref name="item"/> value, if <paramref name="item"/> is null (has no value) then an empty sequence is returned.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.AsEnumerable``1(``0)">
            <summary>
            Converts an struct value an IEnumerable&lt;T&gt;
            </summary>
            <typeparam name="T">The type to convert to a sequence</typeparam>
            <param name="item">The item to place in the sequence</param>
            <returns>A sequence containing the <paramref name="item"/> value</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.NotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Filters out all null values
            </summary>
            <typeparam name="T">The type to filter</typeparam>
            <param name="items">The items to filter</param>
            <returns>A sequence containing all the non-null values in <paramref name="items"/></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.NotNull``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>
            Filters out all null values
            </summary>
            <typeparam name="T">The type to filter</typeparam>
            <param name="items">The items to filter</param>
            <returns>A sequence containing all the non-null values in <paramref name="items"/> (where HasValue = true).</returns>
            <remarks>Note the result is no longer contains Nullable objects</remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.Concat``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Concatenates 0-n sequences into a single sequence.
            </summary>
            <typeparam name="T">The type of the object in each sequence</typeparam>
            <param name="collections">0-n sequences to be combined.</param>
            <returns>A sequence containing all the values in all the <paramref name="collections"/></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{LiquidTechnologies.XmlObjects.BigDecimal}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> values.
            </summary>
            <typeparam name="TSource">The items in the collection</typeparam>
            <param name="source"> A sequence of <typeparamref name="TSource"/> values to calculate the sum of.</param>
            <param name="selector">Gets a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>  from an item in the <paramref name="source"/></param>
            <returns>The sum of the values in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">selector or source is null</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,LiquidTechnologies.XmlObjects.BigDecimal})">
            <summary>
            Computes the sum of a sequence of <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> values.
            </summary>
            <typeparam name="TSource">The items in the collection</typeparam>
            <param name="source"> A sequence of <typeparamref name="TSource"/> values to calculate the sum of.</param>
            <param name="selector">Gets a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>  from an item in the <paramref name="source"/></param>
            <returns>The sum of the values in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">selector or source is null</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.Sum(System.Collections.Generic.IEnumerable{LiquidTechnologies.XmlObjects.BigDecimal})">
            <summary>
            Computes the sum of a sequence of <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> values.
            </summary>
            <param name="source"> A sequence of <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> values to calculate the sum of.</param>
            <returns>The sum of the values in the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">source is null</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.ReplaceInnerXml(System.Xml.Linq.XElement,System.String,System.Xml.XmlNamespaceManager)">
            <summary>
            Replaces the contents of the <see cref="T:System.Xml.Linq.XElement"/> (not the attributes) with the XML data parsed from <paramref name="xmlInnerContent"/>
            </summary>
            <param name="element">The target <see cref="T:System.Xml.Linq.XElement"/></param>
            <param name="xmlInnerContent">The XML data to be parsed and placed into the <paramref name="element"/>.</param>
            <param name="xmlNamespaceManager">A <see cref="T:System.Xml.XmlNamespaceManager"/> to provide namespace context information for XML string in <paramref name="xmlInnerContent"/></param>
            <example>
            <code>
                XElement element = ... 
                element.ReplaceInnerXml("some &lt;b&gt;basic&gt;b&gt; html");
            </code>
            </example>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.ReplaceInnerXml(System.Xml.Linq.XElement,System.String)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxLinqExtensions.ReplaceInnerXml(System.Xml.Linq.XElement,System.String,System.Xml.XmlNamespaceManager)"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.ILxNillable">
            <summary>
            Helper interface for extracting data from the generic
            form of <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/>.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.ILxNillable.IsNil">
            <summary>
            Indicates whether the XML element is a nil.<br/>
            When true the attribute xsi:nil="true" is added to the element, and its contents (text and child nodes) are omitted.
            When false the element is written out complete with its content.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.ILxNillable.Value">
            <summary>
            The underlying value that will become the contents of the 
            XML element when <see cref="P:LiquidTechnologies.XmlObjects.ILxNillable.IsNil"/> is false.
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxNillable`1">
            <summary>
            Encapsulates the XSD concept of xsd:nillable, which is represented in an
            XML document by adding the attribute xsi:nil="true" to an element that is
            deemed to have a nil value.
            </summary>
            <typeparam name="T">The type of the underlying value to be used for the content of the XML element</typeparam>
            <remarks>
            The xsd:nillable concept is often confused with the concept of optional elements.<br/>
            If an element is nillable then it is still represented in the XML document, but it contains no content (text or child nodes), 
            if it is optional and missing it is simply not there.<br/>
            When a property is optional and the value is not set then its value will be null.<br/>
            When a property is required and nillable the LxNillable wrapper will be used, the element will always appear in the XML 
            document, but the <see cref="P:LiquidTechnologies.XmlObjects.LxNillable`1.IsNil"/> property will determine if it contains any contents.<br/>
            When a property is optional and nillable setting the property to null will cause it to be omitted from the XML document,
            setting it to an instance of a <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/> object will cause it appear in the XML document and the 
            <see cref="P:LiquidTechnologies.XmlObjects.LxNillable`1.IsNil"/> property will determine if it contains any contents.<br/>
            For usage and examples see <a href="GC_Nillable">Working with xs:nillable elements</a>
            </remarks>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxNillable`1._value">
            <summary>
            The underlying value that will become the contents of the 
            XML element when <see cref="P:LiquidTechnologies.XmlObjects.LxNillable`1.IsNil"/> is false.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxNillable`1._isNil">
            <summary>
            Indicates whether the XML element is a nil.
            When true the attribute xsi:nil="true" is added to the element, and its contents (text and child nodes) are omitted.
            When false the element is written out complete with its content.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxNillable`1.Create(`0,System.Boolean)">
            <summary>
            Creates a <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/> wrapper for a class type
            </summary>
            <param name="value">The value to be wrapped</param>
            <param name="isNil">Indicates if the contained value is Nil</param>
            <returns>The wrapped value (or null if <paramref name="value"/> is null)</returns>
            <remarks>
            If the <paramref name="value"/> is null then null is returned (indicating that the value is optional but missing).<br/>
            When the type <typeparamref name="T"/> is a struct it is not possible to set <paramref name="value"/> to null, 
            so if the property is optional and should be omitted null should be set directly into the property.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxNillable`1.Create(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Converts a sequence of values into a sequence of <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/>
            wrapper classes, where <see cref="P:LiquidTechnologies.XmlObjects.LxNillable`1.IsNil"/> is set to false.
            </summary>
            <param name="values">The sequence of values to convert (null values are ignored)</param>
            <returns>The sequence of <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/> wrapper objects</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxNillable`1.#ctor(`0,System.Boolean)">
            <summary>
            Creates a <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/> wrapper for a value of type <typeparamref name="T"/>.
            </summary>
            <param name="value">The value to be wrapped (can not be null even if isNil is true)</param>
            <param name="isNil">Indicates if xsi:nil will be true or omitted, see <see cref="P:LiquidTechnologies.XmlObjects.LxNillable`1.IsNil"/></param>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxNillable`1.Value">
            <summary>
            The underlying value that will become the contents of the 
            XML element when <see cref="P:LiquidTechnologies.XmlObjects.LxNillable`1.IsNil"/> is false.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxNillable`1.IsNil">
            <summary>
            Indicates whether the XML element is a nil.
            When true the attribute xsi:nil="true" is added to the element, and its contents (text and child nodes) are omitted.
            When false the element is written out complete with its content.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxNillable`1.op_Implicit(LiquidTechnologies.XmlObjects.LxNillable{`0})~`0">
            <summary>
            Implicitly converts a <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/> to its contained value
            </summary>
            <param name="nillableWrapper">The nillable wrapper to extract the value from</param>
            <returns>
            If <paramref name="nillableWrapper"/> is null and <typeparamref name="T"/> is a class then null is returned.
            If <paramref name="nillableWrapper"/> is null and <typeparamref name="T"/> is a struct then default(T) is returned.
            Otherwise the <see cref="P:LiquidTechnologies.XmlObjects.LxNillable`1.Value"/> contained in <paramref name="nillableWrapper"/> is returned.
            </returns>
            <example>
            <![CDATA[
            LxNillable<int> ni = LxNillable<int>.Create(5);
            int i = ni;
            ]]>
            </example>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxNillable`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.LxNillable{`0}">
            <summary>
            implicitly converts a value to a <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/> object
            </summary>
            <param name="value">The value to convert to a <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/></param>
            <returns>
            If the <paramref name="value"/> is non-null then a <see cref="T:LiquidTechnologies.XmlObjects.LxNillable`1"/> object is returned
            wrapping the <paramref name="value"/>(with <see cref="P:LiquidTechnologies.XmlObjects.LxNillable`1.IsNil"/> set to false).
            If <paramref name="value"/> is null then null is returned.
            </returns>
            <example>
            <![CDATA[
            int i = 5;
            LxNillable<int> ni = i;
            ni = 7;
            ]]>
            </example>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxSerializer`1">
            <summary>
            A generic wrapper around the <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer"/> class.
            </summary>
            <typeparam name="T">The type to be serialized/de-serialized</typeparam>
            <remarks>
            It is possible to define several <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer`1"/> classes (with different types) 
            based on the same underlying <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer"/> instance.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.#ctor(System.Reflection.Assembly[])">
            <summary>
            Constructor (creates a new <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer"/> instance internally)
            </summary>
            <param name="assembliesToScan">
            An optional list of assemblies to search for Liquid XML Objects serialization classes.<br/>
            If no assemblies are provided all loaded assemblies are included.<br/>
            The assembly containing the type <typeparamref name="T"/> is always included.<br/>
            <br/>
            NOTE: On .Net Standard 1.6 and below, you must explicitly supply a list any additional 
            assemblies (it only automatically adds the assembly containing <typeparamref name="T"/>).
            </param>
            <remarks>
            The creation of the internal <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer"/> class is quite expensive, 
            if multiple <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer`1"/> classes need to be constructed then for 
            performance reasons it may be advantageous to explicitly create an instance
            of <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer"/> and use the constructor <see cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.#ctor(LiquidTechnologies.XmlObjects.Serializer)"/>.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.#ctor(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Constructor (using an existing <see cref="T:LiquidTechnologies.XmlObjects.Serializer"/> instance)
            </summary>
            <param name="baseSerializer">An existing <see cref="T:LiquidTechnologies.XmlObjects.Serializer"/></param>
            <remarks>
            Allows the serializer to be intialized from an existing <see cref="T:LiquidTechnologies.XmlObjects.Serializer"/> instance (i.e. a <see cref="T:LiquidTechnologies.XmlObjects.LxSerializer"/> or <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/> instance). 
            The creation of a new serializer can be quite expensive as it needs to scan for LXO generated objects. 
            So for performance reasons it may make sense to only perform this work once.
            
            The assembly containing the type <typeparamref name="T"/> is automatically added to <paramref name="baseSerializer"/>.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.String,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.String,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.IO.Stream,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.IO.TextReader,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.Xml.XmlReader,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.String,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <param name="filename">The file the XML data will be read from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <param name="stream">The <see cref="T:System.IO.Stream"/> the data will be read from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <param name="textReader">The <see cref="T:System.IO.TextReader"/> to read the xml data from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <summary>
            Creates an instance of <typeparamref name="T"/> from the data in the <paramref name="xmlReader"/>
            </summary>
            <returns>A new instance of <typeparamref name="T"/> loaded with data from the <paramref name="xmlReader"/></returns>
            <exception cref="T:System.InvalidCastException">If the object created from the XML Data is not castable to the type in <typeparamref name="T"/>
            (this is typically the case if an the XML file contains the wrong root element for <typeparamref name="T"/>).</exception>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxException">General errors</exception>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Serialize(System.String,`0,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes a class of type <typeparamref name="T"/> to file.
            </summary>
            <param name="filename">The file to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Serialize(System.Xml.XmlWriter,`0,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Serialize(System.IO.Stream,`0,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes a class of type <typeparamref name="T"/> to an <see cref="T:System.IO.Stream"/>.
            </summary>
            <param name="stream">The stream to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Serialize(System.Xml.XmlWriter,`0,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Serialize(System.IO.TextWriter,`0,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes a class of type <typeparamref name="T"/> to an <see cref="T:System.IO.TextWriter"/>.
            </summary>
            <param name="textWriter">The <see cref="T:System.IO.TextWriter"/> to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Serialize(System.Xml.XmlWriter,`0,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer`1.Serialize(System.Xml.XmlWriter,`0,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes a class of type <typeparamref name="T"/> to an <see cref="T:System.Xml.XmlWriter"/>.
            </summary>
            <param name="xmlWriter">The <see cref="T:System.Xml.XmlWriter"/> to write the XML data to</param>
            <param name="element">The Liquid XML Objects attributed class to serialize</param>
            <param name="settings">The Liquid XML Objects settings to control the serialization</param>
            <param name="elementName">The name of the root XML element. Only required if <typeparamref name="T"/> is a complexType (attributed with <see cref="T:LiquidTechnologies.XmlObjects.Attribution.LxComplexTypeDefinitionAttribute"/>).</param>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxSerializer">
            <summary>
            Performs serialization an de-serialization of classes marked up with the 
            Liquid XML Objects serialization attributes.
            </summary>
            <remarks>
            The LxSerializer class can be quite expensive to create as it needs to scan
            assemblies for classes marked up with the Liquid XML Objects serialization attributes.
            For this reason is may be advantageous to cache a copy of the object and re-use
            it rather than re-creating it on demand.
            
            The class is currently NOT thread safe. An instance of LxSerializer should be
            created for each thread that uses it.
            </remarks>
            <example>
            Simple Reader Example
            <code>
            LxSerializer serializer = new LxSerializer(typeof(MyElementClass).Assembly);
            using (XmlReader reader = XmlReader.Create("MyXmlFile.xml"))
            {
                MyElementClass elmCls = (MyElementClass)serializer.Deserialize(reader);
                ...
            }
            </code>
            
            Simple Writer Example
            <code>
            MyElementClass elmCls = ...;
            XmlWriterSettings xws = new XmlWriterSettings() { Indent = true };
            LxWriterSettings lxs = new LxWriterSettings { };
            
            using (XmlWriter writer = XmlWriter.Create("MyXmlFile.xml", xws))
            {
                serializer.Serialize(writer, lxs, elmCls);
            }
            </code>
            </example>
            <seealso cref="T:LiquidTechnologies.XmlObjects.LxSerializer`1"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxSerializer.Version">
            <summary>
            The version of the runtime - must match the version in the generated code
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxSerializer.NugetVersion">
            <summary>
            The version of the Nuget the LXO runtime is contained within. A string in the form X.X.X
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.#ctor(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Constructs an LxSerializer, required for serializing and de-serializing Liquid XML Objects attributed classes. Uses the
            type information registered with the <paramref name="serializer"/>
            </summary>
            <param name="serializer">
            An existing serializer with type information already registered. This type information will then be available to this serializer.
            </param>
            <remarks>
            Allows the serializer to be intialized from an existing <see cref="T:LiquidTechnologies.XmlObjects.Serializer"/> instance (typically this would be
            a serializer of a different type i.e. <see cref="T:LiquidTechnologies.XmlObjects.LjSerializer"/>). The creation of a new serializer can be quite 
            expensive as it needs to scan for LXO generated objects. So for performance reasons it may make sense to only 
            perform this work once.
            
            This class uses the <paramref name="serializer"/> object, so any assemblies registered against this object using the <see cref="M:LiquidTechnologies.XmlObjects.LxSerializer.RegisterAssembly(System.Reflection.Assembly,System.Predicate{System.Type})"/>,
            will also be registered against the <paramref name="serializer"/> object.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.#ctor(System.Reflection.Assembly[])">
            <summary>
            Constructs an LxSerializer, required for serializing and de-serializing Liquid XML Objects attributed classes.
            </summary>
            <param name="assembliesToScan">
            An optional list of assemblies to scan for Liquid XML Objects serialization classes.<br/>
            If no assemblies are provided then ALL assemblies are scanned.<br/>
            </param>
            <remarks>
            Additional assemblies can be added to the scan list later using the <see cref="M:LiquidTechnologies.XmlObjects.LxSerializer.RegisterAssembly(System.Reflection.Assembly,System.Predicate{System.Type})"/> method.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.#ctor(System.Predicate{System.Type},System.Reflection.Assembly[])">
            <summary>
            Constructs an LxSerializer, required for serializing and de-serializing Liquid XML Objects attributed classes.
            </summary>
            <param name="assembliesToScan">
            An optional list of assemblies to scan for Liquid XML Objects serialization classes.<br/>
            If no assemblies are provided then ALL assemblies are scanned.<br/>
            </param>
            <param name="classRegistrationFilter">
            Makes it possible to select which classes are registered with the serializer (the function should return true to register the class).
            </param>
            <remarks>
            Additional assemblies can be added to the scan list later using the <see cref="M:LiquidTechnologies.XmlObjects.LxSerializer.RegisterAssembly(System.Reflection.Assembly,System.Predicate{System.Type})"/> method.
            </remarks>
            <example>
            <![CDATA[
            var companySerializer = new LxSerializer(type => type.Namespace.StartsWith("MyProject.MyCompanyXSD."));
            var companyEmployeeSerializer = new LxSerializer<MyProject.MyCompanyXSD.EmployeeElm>(companySerializer);
            var companyEmployee = companyEmployeeSerializer.Deserialize(@"C:\CompanyEmployee.xml");
            ]]></example>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Serialize(System.String,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">
            <param name="filename">The stream to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Serialize(System.IO.TextWriter,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Serialize(System.IO.Stream,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">
            <param name="stream">The stream to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Serialize(System.IO.TextWriter,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Serialize(System.IO.TextWriter,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">
            <param name="textWriter">The xml writer to write the XML data to</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Serialize(System.Xml.XmlWriter,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)"/>
            <remarks>
            The XML data written is indented and encoded using UTF-8.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Serialize(System.Xml.XmlWriter,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">
            <summary>
            Serializes an Liquid XML Objects attributed class to an <see cref="T:System.Xml.XmlWriter"/>.
            </summary>
            <param name="xmlWriter">The <see cref="T:System.Xml.XmlWriter"/> to write the XML data to</param>
            <param name="elementObj">The Liquid XML Objects attributed class to serialize</param>
            <param name="settings">The Liquid XML Objects settings to control the serialization, default configuration is used if null</param>
            <param name="elementName">The name of the root XML element. Only required if the <paramref name="elementObj"/> is a complexType (attributed with <see cref="T:LiquidTechnologies.XmlObjects.Attribution.LxComplexTypeDefinitionAttribute"/>).</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.String,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.String,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.String,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <param name="filename">The file the XML data will be read from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.IO.Stream,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.IO.Stream,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <param name="stream">The <see cref="T:System.IO.Stream"/> the data will be read from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.IO.TextReader,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.IO.TextReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <param name="textReader">The <see cref="T:System.IO.TextReader"/> to read the xml data from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlElement,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlElement,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlElement,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <param name="xmlElement">The <see cref="T:System.Xml.XmlElement"/> to read the xml data from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.Linq.XElement,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.Linq.XElement,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.Linq.XElement,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <param name="xmlElement">The <see cref="T:System.Xml.Linq.XElement"/> to read the xml data from</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.Deserialize(System.Xml.XmlReader,System.Xml.XmlQualifiedName@,LiquidTechnologies.XmlObjects.LxReaderSettings)">
            <summary>
            De-serializes an XML document, creating a class populated with the data from the XmlReader.
            </summary>
            <param name="xmlReader">The <see cref="T:System.Xml.XmlReader"/> to read the XML data from</param>
            <param name="rootElementQName">
            The qualified name of the root element (useful when the root element contains an xsi:type attribute 
            and the class returned is attributed with <see cref="T:LiquidTechnologies.XmlObjects.Attribution.LxComplexTypeDefinitionAttribute"/>), in which case 
            the value of <paramref name="rootElementQName"/> will be needed in <see cref="M:LiquidTechnologies.XmlObjects.LxSerializer.Serialize(System.Xml.XmlWriter,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.Xml.XmlQualifiedName)">Serialize</see> 
            </param>
            <param name="settings">A settings to control how the data is de-serialized</param>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxException">General errors</exception>
            <returns>The de-serialized object</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.RegisterAssembly(System.Reflection.Assembly,System.Predicate{System.Type})">
            <summary>
            Registers an assembly and all the Liquid XML Objects attributed classes within it with the serializer.
            </summary>
            <param name="assembly">The assembly to register</param>
            <remarks>
            The assembly is already registered then it is ignored and no action is taken.</remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxSerializer.CreateRootElement(System.Xml.XmlReader,LiquidTechnologies.XmlObjects.LxReaderSettings,System.Type,System.Xml.XmlQualifiedName@)">
            <summary>
            
            </summary>
            <param name="xmlReader"></param>
            <param name="settings"></param>
            <param name="assignableFromType">
            DONT THINK THIS IS NEEDED ANYMORE
            (optional) Can be null. If present then it must be possible to assign the root type to this type (i.e. the returned type will be derive from this type)
            Required when the root XML element contains an xsi:type attribute, in this case the type information is described in the xsi:type attribute, and <paramref name="assignableFromType"/> 
            should be the common base class.</param>
            <param name="elementQName"></param>
            <returns></returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.ABCDStruct">
            <summary>
            Simple struct for the (a,b,c,d) which is used to compute the mesage digest.    
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.MD5">
            <summary>
            Raw implementation of the MD5 hash algorithm rom RFC 1321.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.MetadataTypeInfoCache.FindElementType(LiquidTechnologies.XmlObjects.LxReaderSettings,System.Xml.XmlQualifiedName,System.Xml.XmlQualifiedName,System.Type)">
            <summary>
            
            </summary>
            <param name="settings">The reader settings</param>
            <param name="elementQName">must be the qualified name of an element</param>
            <param name="complexTypeQName">can be empty</param>
            <param name="assignableType">can be null</param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.MetadataClass.CanBeEmpty(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Indicates if the compositor can contain no elements
            Looks at the contents of the compositor and figures out if it could be empty 
            i.e. 
                a choice with no items
                a choice with at least 1 optional item
                a sequence with ALL items optional 
                an all with ALL items optional 
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.MetadataClassCompositor">
            <summary>
            LxElementAlternativeAttribute
            LxElementAnyAttribute
            LxElementUnprocessedAttribute
            LxCompositorAttribute
            LxOpenContentAttribute
            LxElementNamedAttribute
                LxElementCtAttribute
                LxElementRefAttribute
                LxElementValueAttribute
                
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.MetadataClassCompositor.Items">
            <summary>
            any, named elements, and compositors (in order - hopefully)
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.MetadataClassCompositor.#ctor(System.Type)">
            <summary>
            Builds the type information from the element type provided
            </summary>
            <param name="elementType">The type of the element object that this will contain the type information from</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.MetadataClassCompositor.CanProcessElement(LiquidTechnologies.XmlObjects.Serializer,System.Xml.XmlQualifiedName,LiquidTechnologies.XmlObjects.LookAheadMode)">
            <summary>
            Indicates if this compositor can process the element named in <paramref name="elementQName"/>.
            It just indicates that its an acceptable starting point, nothing more.
            </summary>
            <param name="serializer"></param>
            <param name="elementQName"></param>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.MetadataClassCompositor.CanBeEmpty(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Indicates if the compositor can contain no elements
            Looks at the contents of the compositor and figures out if it could be empty 
            i.e. 
                a choice with no items
                a choice with at least 1 optional item
                a sequence with ALL items optional 
                an all with ALL items optional 
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.MetadataClassContainer">
            <summary>
            LxElementAlternativeAttribute
            LxElementAnyAttribute
            LxElementUnprocessedAttribute
            LxCompositorAttribute
            LxOpenContentAttribute
            LxElementNamedAttribute
                LxElementCtAttribute
                LxElementEnumAttribute
                LxElementListAttribute
                LxElementRefAttribute
                LxElementUnionAttribute
                LxElementValueAttribute
                
            Holds the type information relating to a given elements child attributes
               
            Deals with all the properties on the element that are attributed with LxAttributeBaseAttribute
            This should include the following types
                LxAttributeAnyAttribute
                LxAttributeUnprocessedAttribute
                LxAttributeEnumAttribute
                LxAttributeListAttribute
                LxAttributeUnionAttribute
                LxAttributeValueAttribute  
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.MetadataClassContainer.NamedAttributes">
            <summary>
            Holds a map of the attribute names to the property and type information that describes them
            May be null if no named attributes are provided
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.MetadataClassContainer.AnyAttributes">
            <summary>
            Holds a the property and type information for the 'any attributes' collection
            May be null if 'any attributes' are not allowed
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.MetadataClassContainer.UnprocessedAttributes">
            <summary>
            Holds a the property and type information for the 'additional attributes' collection
            May be null if 'additional attributes' are not allowed
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.MetadataClassContainer.#ctor(System.Type)">
            <summary>
            Builds the type information from the element type provided
            </summary>
            <param name="elementType">The type of the element object that this will contain the type information from</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.MetadataClassContainer.CanBeEmpty(LiquidTechnologies.XmlObjects.Serializer)">
            <summary>
            Indicates if the compositor can contain no elements
            Looks at the contents of the compositor and figures out if it could be empty 
            i.e. 
                a choice with no items
                a choice with at least 1 optional item
                a sequence with ALL items optional 
                an all with ALL items optional 
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.ParsedSimpleTypeData.NumericPattern">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.Attribution.ILxValueAttribute.NumericPattern" />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ParsedSimpleTypeData.ConvertAndValidateStringToValue(LiquidTechnologies.XmlObjects.Serializer,System.String,LiquidTechnologies.XmlObjects.ILxSettings,System.Object@,System.String@,LiquidTechnologies.XmlObjects.ConversionErrorType@)">
            <summary>
            Converts an XML string value to the .Net typed representation of the value.
            Type validation and facet validation are performed
            </summary>
            <param name="serializer"></param>
            <param name="textValue">The XML string value tp convert</param>
            <param name="lxSettings">The serialization settings</param>
            <param name="typedValue">out : Contains a .Net typed value that represents the converted <paramref name="textValue"/> value. Can be null if the conversion failed and false was returned.</param>
            <param name="errorMsg">out : a string containing any errors associated with the conversion.</param>
            <param name="errorType">out : if false is returned then this contains the source of the error (either converting the value to a string, or validating the facets on the value).</param>
            <returns>true if the conversion and validation was a success, false if an error occurred in the conversion or the validation.</returns>
            <remarks>A value will still be returned via <paramref name="typedValue"/> if the function returns false, but the <paramref name="errorType"/> is FacetError.</remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ParsedSimpleTypeData.TryConvertPrimitiveToString(LiquidTechnologies.XmlObjects.Serializer,System.Object,LiquidTechnologies.XmlObjects.LxWriterSettings,System.String@,System.String@,LiquidTechnologies.XmlObjects.ConversionErrorType@)">
            <summary>
            Expects the 
            </summary>
            <param name="serializer"></param>
            <param name="typedValue"></param>
            <param name="settings"></param>
            <param name="stringValue"></param>
            <param name="errorMsg"></param>
            <param name="errorType"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ParsedSimpleTypeData.ValidateValue(System.String,System.Object,LiquidTechnologies.XmlObjects.ILxSettings,System.String@)">
            <summary>
            Validates the values against the facet rules
            </summary>
            <param name="textValue">The String value as it appears in the XML document</param>
            <param name="lxSettings">The serialization settings</param>
            <param name="typedValue">The typed value returned either from the object model or returned from TryConvertStringToValue</param>
            <param name="errorMsg">Validation error message</param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ParsedSimpleTypeData.ValidateList(System.String,System.Object,System.String@)">
            <summary>
            Validates the values against the facet rules
            </summary>
            <param name="textValue">The String value as it appears in the XML document</param>
            <param name="typedValue">The typed value returned either from the object model or returned from TryConvertStringToValue</param>
            <param name="errorMsg">Validation error message</param>
            <returns></returns>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.ClassElementCompositorAllWriter.DisplayPath">
            <inheritdoc/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.ClassElementCompositorSequenceWriter.DisplayPath">
            <inheritdoc/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.ClassElementCompositorSimpleWriter.DisplayPath">
            <inheritdoc/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.ClassElementContainerWriter.DisplayPath">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ClassElementContainerWriter.WriteStartElement(System.Xml.XmlWriter,LiquidTechnologies.XmlObjects.LxAttributeWriter,System.Object)">
            <summary>
            Writes the Start Element Tag
            and sorts out the namespaces for the element.
            (The main purpose of breaking this out is so we can apply different rules for the root element)
            </summary>
            <param name="xmlWriter"></param>
            <param name="attrWiter"></param>
            <param name="sourceObject"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.ClassElementRootWriter.WriteStartElement(System.Xml.XmlWriter,LiquidTechnologies.XmlObjects.LxAttributeWriter,System.Object)">
            <summary>
            Writes the Start Element Tag and sorts out the namespaces for the element.
            As this is the root element we register all the namespaces described in <see cref="P:LiquidTechnologies.XmlObjects.LxWriterSettings.NamespaceMap"/>
            </summary>
            <param name="xmlWriter"></param>
            <param name="attrWiter"></param>
            <param name="sourceObject"></param>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxAttributeWriter">
            <summary>
            Writes ALL the attributes on the class for a given 
            ClassInfoElementContainer
            
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriter.DisplayPath">
            <summary>
            Gets the path to the current element being written
            </summary>
            <example>
                /FpML(DataDocument)/xs:sequence/trade/xs:sequence/creditDefaultSwap/xs:sequence/generalTerms/xs:sequence/scheduledTerminationDate/xs:choice/adjustableDate/xs:sequence/xs:choice/dateAdjustments
            </example>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxWriterSettings">
            <summary>
            Provides settings that affect how the writing/serialization of a Liquid XML Objects attributed class to an XML document.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxWriterSettings.#ctor">
            <summary>
            Creates a new <see cref="T:LiquidTechnologies.XmlObjects.LxWriterSettings"/>
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriterSettings.ErrorHandler">
            <summary>
            The error handler callback that is called when an error occurs during the serialization process
            </summary>
            <exception cref="T:System.ArgumentNullException">If its set to null</exception>
            <remarks>
            The Default error handler throws a <see cref="T:LiquidTechnologies.XmlObjects.LxSerializationException"/> for errors and ignores warnings
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriterSettings.DefaultTimeZone">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.ILxSettings.DefaultTimeZone"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriterSettings.FloatFormatOverride">
            <summary>
            Allows the formatting of xs:float to be overridden.
            </summary>
            <remarks>
            By Default a float value is formatted as follows
            <code>
            float value = ...
            string strValue = value.ToString(CultureInfo.InvariantCulture);
            </code>
            This property allows a format string to be provided 
            <code>
            float value = ...
            string strValue = value.ToString(FloatFormatOverride, CultureInfo.InvariantCulture);
            </code>
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriterSettings.DoubleFormatOverride">
            <summary>
            Allows the formatting of xs:double to be overridden.
            </summary>
            <remarks>
            By Default a double value is formatted as follows
            <code>
            double value = ...
            string strValue = value.ToString(CultureInfo.InvariantCulture);
            </code>
            This property allows a format string to be provided 
            <code>
            double value = ...
            string strValue = value.ToString(DoubleFormatOverride, CultureInfo.InvariantCulture);
            </code>
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriterSettings.OmitXsiType">
            <summary>
            Prevents the xsi:type attribute from being written out. (Default is false)
            </summary>
            <remarks>
            The xsi:type attribute is only output when it is required to make the generated XML valid. 
            However, some older systems can not cope with it an raise errors.<br/>
            WARNING: Only set to true if you are having problems with the receiving system failing because the XML data contains xsi:type attributes.<br/>
            Setting this to true is likley to cause data to be lost or errors to be generated if the generated XML data is re-read by this library.
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriterSettings.BoolRepresentation">
            <summary>
            Indicates how a xs:boolean value should be rendered within the XML document (default is <see cref="F:LiquidTechnologies.XmlObjects.BoolRepresentationType.TrueFalse"/>)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriterSettings.WriteBannerComment">
            <summary>
            Turns on or off the writing of the banner comment at the start of the serialized XML.
            NOTE: this can NOT be turned off in the free Community Mode.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxWriterSettings.NamespaceMap">
            <summary>
            All the namespace declarations that will be added to the root element of the document.
            Namespaces that are required and that are not in this list will be declared within the element they are required in,
            this can significantly increase the size of an XML document.
            The Key value is the namespace alias, the value is the namespace uri.
            To declare the default namespace for the document Key should be and empty string.
            </summary>
            <example>
            <![CDATA[
            If the namespace xmlns:gsm="http://www.google.com/sitemap" then the code would look like
            myWriterSettings.NamespaceMap["gsm"] = "http://www.google.com/sitemap";
            ]]>
            </example>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxSerializerErrorHandler">
            <summary>
            A callback error handler to deal with errors that occur during the serialization of Liquid XML Objects attributed class to an XML document.
            </summary>
            <param name="msg">The error message describing the issue</param>
            <param name="severity">The severity of the error </param>
            <param name="errorCode">The error code providing detail about the issue</param>
            <param name="targetObject">The object the data is being serialized (a Liquid XML Objects generated class)</param>
            <remarks>The handler either choose to ignore the error or throw an exception to halt the de-serialization process.</remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.StringUtilities.Truncate(System.String,System.Int32,System.Boolean)">
            <summary>
            returns up to maxLen chars from the string.
            </summary>
            <param name="str">The string to truncate</param>
            <param name="maxLen">The max length of the string</param>
            <param name="appendElipsis">If true and the string is truncated then ... is the last 3 chars</param>
            <returns>upto the first maxLen chars from the str.</returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.TextLocation">
            <summary>
            Represents a position within text in terms of a line and column.<br/>
            The indexes are 1 based.<br/>
            The class is immutable.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.TextLocation.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a new <see cref="T:LiquidTechnologies.XmlObjects.TextLocation"/>
            </summary>
            <param name="line">The line number (1 based index)</param>
            <param name="col">The column number (1 based index)</param>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.TextLocation.Line">
            <summary>
            The line number (1 based index)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.TextLocation.Column">
            <summary>
            The column number (1 based index)
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.TextLocation.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.TextLocation.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.TextLocation.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.BigDecimal">
            <summary>
            Arbitrary precision decimal.<br/>
            All operations are exact, except for division. Division never determines more digits than the given precision.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.BigDecimal.AlwaysTruncate">
            <summary>
            Specifies whether the significant digits should be truncated to the given precision after each operation.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.BigDecimal.Zero">
            <summary>
            Constant value representing Zero
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.BigDecimal.Precision">
            <summary>
            Sets the maximum precision of division operations.
            If AlwaysTruncate is set to true all operations are affected.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.BigDecimal.Mantissa">
            <summary>
            The part of a floating-point number which represents the significant digits of that number.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.BigDecimal.Exponent">
            <summary>
            The power to which the <see cref="P:LiquidTechnologies.XmlObjects.BigDecimal.Mantissa"/> is to be raised.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.#ctor(System.Int32)">
            <summary>
            Cast Constructor, creates a new <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> from an <see cref="T:System.Int32"/>
            </summary>
            <param name="mantissa">The <see cref="T:System.Int32"/> value to be used to initialize the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.#ctor(System.Int64)">
            <summary>
            Cast Constructor, creates a new <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> from an <see cref="T:System.Int64"/>
            </summary>
            <param name="mantissa">The <see cref="T:System.Int64"/> value to be used to initialize the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.#ctor(System.UInt64)">
            <summary>
            Cast Constructor, creates a new <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> from an <see cref="T:System.UInt64"/>
            </summary>
            <param name="mantissa">The <see cref="T:System.UInt64"/> value to be used to initialize the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.#ctor(System.Numerics.BigInteger)">
            <summary>
            Cast Constructor, creates a new <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> from an <see cref="T:System.Numerics.BigInteger"/>
            </summary>
            <param name="mantissa">The <see cref="T:System.Numerics.BigInteger"/> value to be used to initialize the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.#ctor(System.Double)">
            <summary>
            Cast Constructor, creates a new <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> from an <see cref="T:System.Double"/>
            </summary>
            <param name="mantissa">The <see cref="T:System.Double"/> value to be used to initialize the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.#ctor(System.Decimal)">
            <summary>
            Cast Constructor, creates a new <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> from an <see cref="T:System.Decimal"/>
            </summary>
            <param name="mantissa">The <see cref="T:System.Decimal"/> value to be used to initialize the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.#ctor(System.Numerics.BigInteger,System.Int32)">
            <summary>
            Constructor, creates a new <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> from a mantissa and an exponent.
            </summary>
            <param name="mantissa">The <see cref="T:System.Numerics.BigInteger"/> value to be used to initialize the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
            <param name="exponent">The power to which the <paramref name="mantissa"/> is to be raised.</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.Parse(System.String)">
            <summary>
            Parses the string representation of a decimal into a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> object
            </summary>
            <param name="stringValue">a string representation of a decimal</param>
            <returns>A <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>a representing the  decimal value in <paramref name="stringValue"/></returns>
            <exception cref="T:System.FormatException">If the decimals syntax is invalid</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.TryParse(System.String,LiquidTechnologies.XmlObjects.BigDecimal@)">
            <summary>
            Attempts to parse the string representation of a decimal into a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> object
            </summary>
            <param name="stringValue">a string representation of a decimal</param>
            <param name="result">if ture is returned the this holds a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> representing the decimal value in <paramref name="stringValue"/>, if false is returned this is undefined.</param>
            <returns>true if the decimal string was parsed successfully, false if it was not.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.Normalize">
            <summary>
            Removes trailing zeros on the mantissa
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.Truncate(System.Int32)">
            <summary>
            Truncate the number to the given precision by removing the least significant digits.
            </summary>
            <returns>The truncated number</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.Truncate">
            <summary>
            Truncate the number to the given precision by removing the least significant digits.
            </summary>
            <remarks>Uses the default <see cref="F:LiquidTechnologies.XmlObjects.BigDecimal.Precision"/></remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.SetDecimalPlaces(System.Int32)">
            <summary>
            Gets the value removing any values after the specified number of decimal palces
            </summary>
            <param name="decimalPlaceToKeep"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Implicit(System.Int32)~LiquidTechnologies.XmlObjects.BigDecimal">
            <summary>
            Implicit cast from <see cref="T:System.Int32"/> to <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="value">The <see cref="T:System.Int32"/> value to be converted to a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Implicit(System.Int64)~LiquidTechnologies.XmlObjects.BigDecimal">
            <summary>
            Implicit cast from <see cref="T:System.Int64"/> to <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="value">The <see cref="T:System.Int64"/> value to be converted to a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Implicit(System.UInt64)~LiquidTechnologies.XmlObjects.BigDecimal">
            <summary>
            Implicit cast from <see cref="T:System.UInt64"/> to <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="value">The <see cref="T:System.UInt64"/> value to be converted to a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Implicit(System.Numerics.BigInteger)~LiquidTechnologies.XmlObjects.BigDecimal">
            <summary>
            Implicit cast from <see cref="T:System.Numerics.BigInteger"/> to <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="value">The <see cref="T:System.Numerics.BigInteger"/> value to be converted to a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Implicit(System.Single)~LiquidTechnologies.XmlObjects.BigDecimal">
            <summary>
            Implicit cast from <see cref="T:System.Single"/> to <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="value">The <see cref="T:System.Single"/> value to be converted to a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Implicit(System.Double)~LiquidTechnologies.XmlObjects.BigDecimal">
            <summary>
            Implicit cast from <see cref="T:System.Double"/> to <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="value">The <see cref="T:System.Double"/> value to be converted to a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Implicit(System.Decimal)~LiquidTechnologies.XmlObjects.BigDecimal">
            <summary>
            Implicit cast from <see cref="T:System.Decimal"/> to <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="value">The <see cref="T:System.Decimal"/> value to be converted to a <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Explicit(LiquidTechnologies.XmlObjects.BigDecimal)~System.Double">
            <summary>
            Explicit cast from <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to <see cref="T:System.Double"/>
            </summary>
            <param name="value">The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to cast</param>
            <returns>The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> represented as a <see cref="T:System.Double"/></returns>
            <exception cref="T:System.OverflowException">If the number is to large to fit in a <see cref="T:System.Double"/></exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Explicit(LiquidTechnologies.XmlObjects.BigDecimal)~System.Single">
            <summary>
            Explicit cast from <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to <see cref="T:System.Single"/>
            </summary>
            <param name="value">The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to cast</param>
            <returns>The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> represented as a <see cref="T:System.Single"/></returns>
            <exception cref="T:System.OverflowException">If the number is to large to fit in a <see cref="T:System.Single"/></exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Explicit(LiquidTechnologies.XmlObjects.BigDecimal)~System.Decimal">
            <summary>
            Explicit cast from <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to <see cref="T:System.Decimal"/>
            </summary>
            <param name="value">The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to cast</param>
            <returns>The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> represented as a <see cref="T:System.Decimal"/></returns>
            <exception cref="T:System.OverflowException">If the number is to large to fit in a <see cref="T:System.Decimal"/></exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Explicit(LiquidTechnologies.XmlObjects.BigDecimal)~System.Int32">
            <summary>
            Explicit cast from <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to <see cref="T:System.Int32"/>
            </summary>
            <param name="value">The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to cast</param>
            <returns>The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> represented as a <see cref="T:System.Int32"/></returns>
            <exception cref="T:System.OverflowException">If the number is to large to fit in a <see cref="T:System.Int32"/></exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Explicit(LiquidTechnologies.XmlObjects.BigDecimal)~System.UInt32">
            <summary>
            Explicit cast from <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to <see cref="T:System.UInt32"/>
            </summary>
            <param name="value">The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to cast</param>
            <returns>The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> represented as a <see cref="T:System.UInt32"/></returns>
            <exception cref="T:System.OverflowException">If the number is to large to fit in a <see cref="T:System.UInt32"/></exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Explicit(LiquidTechnologies.XmlObjects.BigDecimal)~System.Int64">
            <summary>
            Explicit cast from <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to <see cref="T:System.Int64"/>
            </summary>
            <param name="value">The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to cast</param>
            <returns>The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> represented as a <see cref="T:System.Int64"/></returns>
            <exception cref="T:System.OverflowException">If the number is to large to fit in a <see cref="T:System.Int64"/></exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Explicit(LiquidTechnologies.XmlObjects.BigDecimal)~System.UInt64">
            <summary>
            Explicit cast from <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to <see cref="T:System.UInt64"/>
            </summary>
            <param name="value">The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to cast</param>
            <returns>The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> represented as a <see cref="T:System.UInt64"/></returns>
            <exception cref="T:System.OverflowException">If the number is to large to fit in a <see cref="T:System.UInt64"/></exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Explicit(LiquidTechnologies.XmlObjects.BigDecimal)~System.Numerics.BigInteger">
            <summary>
            Explicit cast from <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to <see cref="T:System.Numerics.BigInteger"/>
            </summary>
            <param name="value">The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> to cast</param>
            <returns>The <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> represented as a <see cref="T:System.Numerics.BigInteger"/></returns>
            <exception cref="T:System.OverflowException">If the number is to large to fit in a <see cref="T:System.Numerics.BigInteger"/></exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_UnaryPlus(LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_UnaryNegation(LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Increment(LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Decrement(LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Addition(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Subtraction(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Multiply(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Division(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Equality(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_Inequality(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_LessThan(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_GreaterThan(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_LessThanOrEqual(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.op_GreaterThanOrEqual(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.AlignExponent(LiquidTechnologies.XmlObjects.BigDecimal,LiquidTechnologies.XmlObjects.BigDecimal)">
            <summary>
            Returns the mantissa of value, aligned to the exponent of reference.
            Assumes the exponent of value is larger than of reference.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.Exp(System.Double)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.Pow(System.Double,System.Double)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.ToString">
            <summary>The string representation of the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> in its decimal format</summary>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.BigDecimal.ToString(System.String,System.Globalization.CultureInfo)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.ToString(System.String)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.BigDecimal.ToString(System.String,System.Globalization.CultureInfo)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.ToString(System.Globalization.CultureInfo)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.BigDecimal.ToString(System.String,System.Globalization.CultureInfo)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.ToString(System.String,System.Globalization.CultureInfo)">
            <summary>
            Gets the string representation of the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="format">
            'e' for exponent format
            'd' for decimal format (default)
            
            OTHER FORMATTERS HAVE LIMITED FUNCTIONALITY - USE WITH CARE
            In addition the formatting rules are described in <see href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings">Standard numeric format strings</see>
            and <see href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-numeric-format-strings">Custom numeric format strings</see>
            can be used BUT ONLY IF THE VALUE CAN BE HELD INSIDE A <see cref="T:System.Decimal"/>. IF THE VALUE IS TO LARGE IT WILL THROW AN <see cref="T:System.OverflowException"/>.
            </param>
            <param name="cultureInfo"></param>
            <returns>The string representation of the <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.Equals(LiquidTechnologies.XmlObjects.BigDecimal)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.BigDecimal.CompareTo(LiquidTechnologies.XmlObjects.BigDecimal)">
            <summary>
            Compares this <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/> with another <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/>
            </summary>
            <param name="other">The other <see cref="T:LiquidTechnologies.XmlObjects.BigDecimal"/></param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.BigDecimal.CompareTo(System.Object)"/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDateTimeType">
            <summary>
            The type of xsd date type represented.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.None">
            <summary>
            The xsd date/time type could not be determined
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime">
            <summary>
            Represents an xs:dateTime
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date">
            <summary>
            Represents an xs:date
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYearMonth">
            <summary>
            Represents an xs:gYearMonth
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYear">
            <summary>
            Represents an xs:gYear
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Time">
            <summary>
            Represents an xs:time
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GDay">
            <summary>
            Represents an xs:gDay
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonth">
            <summary>
            Represents an xs:gMonth
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonthDay">
            <summary>
            Represents an xs:gMonthDay
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDateTime">
            <summary>
            Contains the value of an XSD
                xs:dateTime,
                xs:dateTimeStamp,
                xs:date,
                xs:gYearMonth,
                xs:gYear,
                xs:time,
                xs:gDay,
                xs:gMonth,
                xs:gMonthDay
            <br/>The class is IMMUTABLE
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult">
            <summary>
            The result of comparing 2 <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> objects
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.Equal">
            <summary>
            The 2 <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> values are equal
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.LessThan">
            <summary>
            The <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> is less than the other <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.GreaterThan">
            <summary>
            The <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> is greater than the other <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.Indeterminate">
            <summary>
            It is not possible to say if one <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> is greater than the other (typically because they are not of the same type - you can not compare an xs:gYear to a xs:gMonth).
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone">
            <summary>
            Determines how dates/times without explicit timezone information should be treated.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone.UTC">
            <summary>
            Dates and times without a timezone are assumed to be UTC
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone.Local">
            <summary>
            Dates and times without a timezone are assumed to be in local time
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime._hasTimeZone">
            <summary>
            The class is relative to UTC0
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime._zuluTimeInLongForm">
            <summary>
            Indicates if a timezone value of 0 should be rendered as +00:00 or Z
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDateTime.Zero">
            <summary>
            The Zero datetime
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Now">
            <summary>
            The current date time (UTC) (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>).
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Today">
            <summary>
            The current date (UTC) (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>).
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateDateTime(System.Int32,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Int16,System.Int16,System.Int16,System.Boolean)">
            <summary>
            Creates a new xsd xs:datetime (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>).
            </summary>
            <param name="year">The year value</param>
            <param name="month">The month value (1-12)</param>
            <param name="day">The day value (1-31)</param>
            <param name="hour">The hour value (0-23)</param>
            <param name="minute">The minute value (0-59)</param>
            <param name="second">The hour (0-59)</param>
            <param name="milli">The millisecond value (0-999)</param>
            <param name="micro">The microsecond value (0-999)</param>
            <param name="nano">The nanosecond value (0-999)</param>
            <param name="isUtc">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateDateTime(System.Int32,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Int16,System.Int16,System.Int16,System.SByte,System.Byte)">
            <summary>
            Creates a new xsd xs:datetime (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>).
            </summary>
            <param name="year">The year value</param>
            <param name="month">The month value (1-12)</param>
            <param name="day">The day value (1-31)</param>
            <param name="hour">The hour value (0-23)</param>
            <param name="minute">The minute value (0-59)</param>
            <param name="second">The hour (0-59)</param>
            <param name="milli">The millisecond value (0-999)</param>
            <param name="micro">The microsecond value (0-999)</param>
            <param name="nano">The nanosecond value (0-999)</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGDay(System.Int32,System.Boolean)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GDay"/>).
            </summary>
            <param name="day">The day value (1-31)</param>
            <param name="isUtc">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGDay(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GDay"/>).
            </summary>
            <param name="day">The day value (1-31)</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGMonth(System.Int32,System.Boolean)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonth"/>).
            </summary>
            <param name="month">The month value (1-12)</param>
            <param name="isUtc">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGMonth(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonth"/>).
            </summary>
            <param name="month">The month value (1-12)</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGMonthDay(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonthDay"/>).
            </summary>
            <param name="month">The month value (1-12)</param>
            <param name="day">The day value (1-31)</param>
            <param name="isUtc">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGMonthDay(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonthDay"/>).
            </summary>
            <param name="month">The month value (1-12)</param>
            <param name="day">The day value (1-31)</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGYear(System.Int32,System.Boolean)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYear"/>).
            </summary>
            <param name="year">The year value</param>
            <param name="isUtc">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGYear(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYear"/>).
            </summary>
            <param name="year">The year value</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGYearMonth(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYearMonth"/>).
            </summary>
            <param name="year">The year value</param>
            <param name="month">The month value (1-12)</param>
            <param name="isUtc">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateGYearMonth(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYearMonth"/>).
            </summary>
            <param name="year">The year value</param>
            <param name="month">The month value (1-12)</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateDate(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>).
            </summary>
            <param name="year">The year value</param>
            <param name="month">The month value (1-12)</param>
            <param name="day">The day value (1-31)</param>
            <param name="isUtc">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateDate(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new xsd xs:date (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>).
            </summary>
            <param name="year">The year value</param>
            <param name="month">The month value (1-12)</param>
            <param name="day">The day value (1-31)</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateTime(System.Byte,System.Byte,System.Byte,System.Int16,System.Int16,System.Int16,System.Boolean)">
            <summary>
            Creates a new xsd xs:time (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Time"/>).
            </summary>
            <param name="hour">The hour value (0-23)</param>
            <param name="minute">The minute value (0-59)</param>
            <param name="second">The hour (0-59)</param>
            <param name="milli">The millisecond value (0-999)</param>
            <param name="micro">The microsecond value (0-999)</param>
            <param name="nano">The nanosecond value (0-999)</param>
            <param name="isUtc">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CreateTime(System.Byte,System.Byte,System.Byte,System.Int16,System.Int16,System.Int16,System.SByte,System.Byte)">
            <summary>
            Creates a new xsd xs:time (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Time"/>).
            </summary>
            <param name="hour">The hour value (0-23)</param>
            <param name="minute">The minute value (0-59)</param>
            <param name="second">The hour (0-59)</param>
            <param name="milli">The millisecond value (0-999)</param>
            <param name="micro">The microsecond value (0-999)</param>
            <param name="nano">The nanosecond value (0-999)</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDDateTime(System.String,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)">
            <summary>
            Parses a string containing an xs:dateTime
            </summary>
            <param name="xsdDateTime">The string to be parsed</param>
            <param name="result">The resulting <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object (if true is returned)</param>
            <param name="ex">The <see cref="T:System.Exception"/> describing the error is the string could not be parsed (and false was returned)</param>
            <returns>true if the string was successfully parsed into a <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>, false if an error occured.</returns>
            <remarks>
            Parses a xs:dateTime string, e.g.<br/>
            <br/>
            "2004-04-12T13:20:00"	= 1:20 pm on April 12, 2004<br/>
            "2004-04-12T13:20:15.5"	= 1:20 pm and 15.5 seconds on April 12, 2004<br/>
            "2004-04-12T13:20:00-05:00"	= 1:20 pm on April 12, 2004, US Eastern Standard Time<br/>
            "2004-04-12T13:20:00Z"	= 1:20 pm on April 12, 2004, Coordinated Universal Time(UTC)
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDDateTimeStamp(System.String,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)">
            <summary>
            Parses a string containing an xs:dateTimeStamp (XSD 1.1)
            </summary>
            <param name="xsdDateTime">The string to be parsed</param>
            <param name="result">The resulting <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object (if true is returned)</param>
            <param name="ex">The <see cref="T:System.Exception"/> describing the error is the string could not be parsed (and false was returned)</param>
            <returns>true if the string was successfully parsed into a <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>, false if an error occurred.</returns>
            <remarks>
            Parses a xs:dateTimeStamp string (a xs:dateTimeStamp is a xs:dateTime with timezone information) e.g.<br/>
            <br/>
            "2004-04-12T13:20:00-05:00"	= 1:20 pm on April 12, 2004, US Eastern Standard Time<br/>
            "2004-04-12T13:20:00Z"	= 1:20 pm on April 12, 2004, Coordinated Universal Time(UTC)
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDDate(System.String,LiquidTechnologies.XmlObjects.LxDateTimeType,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)">
            <summary>
            Parses a string containing an xs:date
            </summary>
            <param name="xsdDate">The string to be parsed</param>
            <param name="dateType">The type of date to parse <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>, <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GDay"/>, <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonth"/>, <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonthDay"/>, <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYear"/>, <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYearMonth"/></param>
            <param name="result">The resulting <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object (if true is returned)</param>
            <param name="ex">The <see cref="T:System.Exception"/> describing the error is the string could not be parsed (and false was returned)</param>
            <returns>true if the string was successfully parsed into a <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>, false if an error occurred.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDTime(System.String,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)">
            <summary>
            Parses a string containing an xs:time
            </summary>
            <param name="xsdTime">The string to be parsed</param>
            <param name="result">The resulting <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object (if true is returned)</param>
            <param name="ex">The <see cref="T:System.Exception"/> describing the error is the string could not be parsed (and false was returned)</param>
            <returns>true if the string was successfully parsed into a <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>, false if an error occurred.</returns>
            <remarks>
            Parses a xs:time string, e.g.<br/>
            <br/>
            "13:20:00"	= 1:20 PM<br/>
            "13:20:30.5555"	= 1:20 PM and 30.5555 seconds<br/>
            "13:20:00-05:00"	1:20 PM, US Eastern Standard Time<br/>
            "13:20:00Z"     =	1:20 PM, Coordinated Universal Time (UTC)<br/>
            "00:00:00"	= midnight<br/>
            "24:00:00"	= midnight<br/>
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParse(System.String,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)">
            <summary>
            Parses a string containing any XSD date time format (    
                xs:dateTime,
                xs:dateTimeStamp,
                xs:date,
                xs:gYearMonth,
                xs:gYear,
                xs:time,
                xs:gDay,
                xs:gMonth,
                xs:gMonthDay)
            </summary>
            <param name="xsdDateTime">The string to be parsed</param>
            <param name="result">The resulting <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object (if true is returned)</param>
            <param name="ex">The <see cref="T:System.Exception"/> describing the error is the string could not be parsed (and false was returned)</param>
            <returns>true if the string was successfully parsed into a <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>, false if an error occurred.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.ParseXSDDateTime(System.String)">
            <returns>The parsed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object</returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxException">If the string is not a valid xs:dateTime.</exception>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDDateTime(System.String,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDDateTimeStamp(System.String)">
            <returns>The parsed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object</returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxException">If the string is not a valid xs:dateTimeStamp.</exception>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDDateTimeStamp(System.String,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.ParseXSDDate(System.String,LiquidTechnologies.XmlObjects.LxDateTimeType)">
            <returns>The parsed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object</returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxException">If the string is not a valid <paramref name="dateType"/>.</exception>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDDate(System.String,LiquidTechnologies.XmlObjects.LxDateTimeType,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.ParseXSDTime(System.String)">
            <returns>The parsed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object</returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxException">If the string is not a valid xs:time.</exception>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDTime(System.String,LiquidTechnologies.XmlObjects.LxDateTime@,System.Exception@)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.#ctor(LiquidTechnologies.XmlObjects.LxDateTime)">
            <summary>
            Copy constructor
            </summary>
            <param name="dt"></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.#ctor(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTimeType)">
            <summary>
            Copies an existing <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>, but changes its type
            </summary>
            <param name="dt">The existing <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> to copy</param>
            <param name="type">The new XSD datetime type</param>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If the conversion is not possible</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.#ctor(System.DateTime)">
            <summary>
            Creates a new <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> from a <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.DateTime"/>
            </summary>
            <param name="dt">The <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.DateTime"/> to copy the value from</param>
            <remarks>The timezone is either UTC or local</remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.#ctor(LiquidTechnologies.XmlObjects.LxDateTimeType,System.Int32,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Int16,System.Int16,System.Int16,System.Boolean)">
            <summary>
            Creates a new xsd date time type
            </summary>
            <param name="type">The required XSD type for the <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></param>
            <param name="year">The year value (0 if not required)</param>
            <param name="month">The month value (1-12 or 0 if not required))</param>
            <param name="day">The day value (1-31 or 0 if not required))</param>
            <param name="hour">The hour value (0-23 or 0 if not required))</param>
            <param name="minute">The minute value (0-59 or 0 if not required))</param>
            <param name="second">The hour (0-59 or 0 if not required))</param>
            <param name="milli">The millisecond value (0-999 or 0 if not required))</param>
            <param name="micro">The microsecond value (0-999 or 0 if not required))</param>
            <param name="nano">The nanosecond value (0-999 or 0 if not required))</param>
            <param name="isUTC">true if the time is a UTC time, false if its a in the local timezone.</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.#ctor(LiquidTechnologies.XmlObjects.LxDateTimeType,System.Int32,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Int16,System.Int16,System.Int16,System.SByte,System.Byte)">
            <summary>
            Creates a new xsd date time type
            </summary>
            <param name="type">The required XSD type for the <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></param>
            <param name="year">The year value (0 if not required)</param>
            <param name="month">The month value (1-12 or 0 if not required))</param>
            <param name="day">The day value (1-31 or 0 if not required))</param>
            <param name="hour">The hour value (0-23 or 0 if not required))</param>
            <param name="minute">The minute value (0-59 or 0 if not required))</param>
            <param name="second">The hour (0-59 or 0 if not required))</param>
            <param name="milli">The millisecond value (0-999 or 0 if not required))</param>
            <param name="micro">The microsecond value (0-999 or 0 if not required))</param>
            <param name="nano">The nanosecond value (0-999 or 0 if not required))</param>
            <param name="zoneHour">The timezone hour value (-23 to +23)</param>
            <param name="zoneMinute">The timezone minute value (0-59)</param>
            <returns>A newly constructed <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/></returns>
            <exception cref="T:LiquidTechnologies.XmlObjects.LxInvalidValueException">If any of the values are out of range</exception>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Type">
            <summary>
            The type of XSD datetime value stored in this <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/>
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.DateTimeOffset">
            <summary>
            Converts the value to a <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <remarks>
            Only possible when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/> or <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/><br/>
            If the <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> has not timezone information then its assumed to be a UTC time
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.GetDateTimeOffset(LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone)">
            <summary>
            Converts the value to a <see cref="T:System.DateTimeOffset"/>.
            </summary>
            <param name="defaultTimeZone">If this <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> has not timezone this flag indicates the timezone information that should be applied.</param>
            <remarks>
            Only possible when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/> or <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/><br/>
            </remarks>
            <returns>This <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> as a <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.DateTimeOffset"/>.</returns>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Time">
            <summary>
            Gets a <see cref="T:System.TimeSpan"/> value that represents the time of the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object.
            </summary>
            <remarks>Only possible when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Time"/> or <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>.
            The timezone is not applied to the time</remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.DateTime">
            <summary>
            Gets a <see cref="T:System.DateTime"/> value that represents the date and time of the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object.
            </summary>
            <remarks>Only possible when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/> or <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/></remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.UtcDateTime">
            <summary>
            Gets a <see cref="T:System.DateTime"/> value that represents the Coordinated Universal Time (UTC)
            date and time of the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object.
            </summary>
            <remarks>Only possible when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/> or <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/></remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.LocalDateTime">
            <summary>
            Gets a <see cref="T:System.DateTime"/> value that represents the local date and time of the current
            <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> object.
            </summary>
            <remarks>Only possible when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/> or <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/></remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.IsYearValid">
            <summary>
            Indicates if the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> has a valid <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Year"/> component
            </summary>
            <remarks>If <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> is 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYearMonth"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYear"/>
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.IsMonthValid">
            <summary>
            Indicates if the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> has a valid <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Month"/> component
            </summary>
            <remarks>If <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> is 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GYearMonth"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonth"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonthDay"/>
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.IsDayValid">
            <summary>
            Indicates if the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> has a valid <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Day"/> component
            </summary>
            <remarks>If <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> is 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GDay"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.GMonthDay"/>
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.IsTimeValid">
            <summary>
            Indicates if the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> has a valid time component (<see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Hour"/>, <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Minute"/>, <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Second"/>, <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.MilliSecond"/>, <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.MicroSecond"/>, <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.NanoSecond"/>)
            </summary>
            <remarks>If <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> is 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/>, 
            <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/>
            </remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Year">
            <summary>
            The year value (0 when not used)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Month">
            <summary>
            The month value (1-12 or 0 when not used)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Day">
            <summary>
            The day value (1-31 or 0 when not used)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Hour">
            <summary>
            The hour value (0-23)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Minute">
            <summary>
            The minute value (0-59)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.Second">
            <summary>
            The hour (0-59)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.MilliSecond">
            <summary>
            The millisecond value (0-999)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.MicroSecond">
            <summary>
            The microsecond value (0-999)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.NanoSecond">
            <summary>
            The nanosecond value (0-999)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.RealSecond">
            <summary>
            The seconds value as a real number
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.DayOfWeek">
            <summary>
            Gets the day of the week represented by the current System.DateTimeOffset object.
            </summary>
            <remarks>Only possible when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/> or <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/></remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.DayOfYear">
            <summary>
            Gets the day of the year represented by the current System.DateTimeOffset object.
            </summary>
            <remarks>Only possible when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> = <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.Date"/> or <see cref="F:LiquidTechnologies.XmlObjects.LxDateTimeType.DateTime"/></remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.HasTimeZone">
            <summary>
            Indicates the <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> is relative to UTC time
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.ZuluTimeInLongForm">
            <summary>
            Indicates how times with a 0 offset from UTC should be shown, either +00:00 or Z.
            Only meaningful when <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.HasTimeZone"/>=true.
            </summary>
            <example>
            When <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.HasTimeZone"/> = true and <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.ZuluTimeInLongForm"/> = true, the result of <see cref="M:LiquidTechnologies.XmlObjects.LxDateTime.ToString"/> would look something like this
            <code>
            2002-09-24-00:00
            </code>
            
            When <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.HasTimeZone"/> = true and <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.ZuluTimeInLongForm"/> = false, the result of <see cref="M:LiquidTechnologies.XmlObjects.LxDateTime.ToString"/> would look something like this
            <code>
            2002-09-24Z
            </code>
            </example>
            <remarks>Included so date times can be round tripped more accurately 2002-09-24-00:00 = 2002-09-24Z (</remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.ZoneHour">
            <summary>
            The timezone hour (-23 to +23)
            </summary>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.HasTimeZone"/> = false</exception>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.ZoneMinute">
            <summary>
            The timezone minute (0 to 59)
            </summary>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.HasTimeZone"/> = false</exception>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.TimeZone">
            <summary>
            The timezone as a <see cref="T:System.TimeSpan"/>
            </summary>
            <exception cref="T:System.InvalidOperationException">If <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.HasTimeZone"/> = false</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.CompareTo(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone)">
            <summary>
            Compares the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> with <paramref name="date1"/>
            </summary>
            <param name="date1">The <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> to compare with</param>
            <param name="defaultTimeZone">Determines how date/times with no timezone are treated</param>
            <returns>
            If the 2 <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> have different <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> then the result is <see cref="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.Indeterminate"/>.
            The 2 values are compared taking the timezone into account. If a <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> does not have a timezone then it is deemed to be a local time.
            If <paramref name="date1"/> is null, it is considered to be less than the current value.
            </returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.Compare(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone)">
            <summary>
            Compares 2 <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> objects
            </summary>
            <param name="date1">The <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> to compare with</param>
            <param name="date2">The <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> to compare with</param>
            <param name="defaultTimeZone">Determines how date/times with no timezone are treated</param>
            <returns>
            If the 2 <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> have different <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> then the result is <see cref="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.Indeterminate"/>.<br/>
            The 2 values are compared taking the timezone into account. If a <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> does not have a timezone then it is deemed to be a local time.<br/>
            If date1 is null and date2 is null then <see cref="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.Equal"/> is returned.<br/>
            If date1 is null then <see cref="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.LessThan"/> is returned.<br/>
            If date2 is null then <see cref="F:LiquidTechnologies.XmlObjects.LxDateTime.CompareResult.GreaterThan"/> is returned.<br/>
            </returns>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDateTime.LocalOffsetToUtc">
            <summary>
            The offset from the local timezone to UTC.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.XsdAddDateTimeSpan(LiquidTechnologies.XmlObjects.LxDuration)">
            <summary>
            Adds an xs:duration to an xs:datetime
            </summary>
            <param name="timespan"></param>
            <returns></returns>
            <remarks>See <see href="https://www.w3.org/TR/xmlschema11-2/#sec-dt-arith">https://www.w3.org/TR/xmlschema11-2/#sec-dt-arith</see></remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDDate(System.String,System.Int32@,System.Byte@,System.Byte@,LiquidTechnologies.XmlObjects.LxDateTimeType@)">
            <summary>
            Attempts to parse an XSD Date part (Just the CCYY-MM-DD part)
            into year/month/day it also indicates the type of the date (i.e. gDay, gMonthDay)
            Does not perform range checking on the values
            </summary>
            <param name="xsdDate"></param>
            <param name="year"></param>
            <param name="month"></param>
            <param name="day"></param>
            <param name="dtType"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDTime(System.String,System.Byte@,System.Byte@,System.Byte@,System.Int16@,System.Int16@,System.Int16@)">
            <summary>
            Attempts to parse an XSD Time part (Just the hh:mm:ss[.ff] part) 
            IT SHOULD NOT CONTAIN THE TIMEZONE PART
            into hour/minute/second/micro/milli/nano.
            Does not perform range checking on the values
            </summary>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.TryParseXSDTimeZone(System.String,System.Boolean@,System.Boolean@,System.SByte@,System.Byte@)">
            <summary>
            Attempts to parse an XSD Time zone part (Just the '', 'Z', '+hh:mm' or '-hh:mm' part) 
            Does not perform range checking on the values
            </summary>/// <param name="strZone"></param>
            <param name="isUTC"></param>
            <param name="hasZone"></param>
            <param name="zoneHour"></param>
            <param name="zoneMinute"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.GetTimeZoneStartIndex(System.String)">
            <summary>
            
            </summary>
            <param name="dateTimeStr">any valid xsd date time formatted string</param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.op_Equality(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime)">
            <summary>
            Compares 2 <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> objects for equality
            </summary>
            <param name="left">first value</param>
            <param name="right">second value</param>
            <returns>
            In order for them to be considered the same the <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> must be the same.
            The timezone is taken into account when comparing them. If an explicit timezone is not
            present then they are considered to be UTC (Zulu time).
            If greater control is required then us <see cref="M:LiquidTechnologies.XmlObjects.LxDateTime.Equals(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone)"/>
            </returns>
            <seealso cref="M:LiquidTechnologies.XmlObjects.LxDateTime.Compare(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone)"/>
            <seealso cref="M:LiquidTechnologies.XmlObjects.LxDateTime.Equals(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.op_Inequality(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime)">
            <summary>
            Compares 2 <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> objects for inequality
            </summary>
            <param name="left">first value</param>
            <param name="right">second value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.LxDateTime.op_Equality(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.ToString(System.String)">
            <summary>
            CURRENTLY ONLY "s" is supported - so no need to expose this
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.Equals(System.Object)">
            <param name="o">The other object to compare this against</param>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDateTime.Equals(LiquidTechnologies.XmlObjects.LxDateTime,LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone)">
            <summary>Compares this <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> with another for equality</summary>
            <param name="dt">The <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> to be compare for equality</param>
            <param name="defaultTimeZone">Determines how date/times with no timezone are treated</param>
            <remarks>
            Compares the current <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> with <paramref name="dt"/> for equality.<br/>
            In order to be considered equal both <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> objects must have the same <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/>.<br/>
            The values are then converted to UTC and compared.<br/>
            Care should be taken when using <see cref="F:LiquidTechnologies.XmlObjects.LxDateTime.DefaultTimeZone.Local"/> in timezones other than UTC0. For example if the local timezone is +05:00, 
            Then the value 10:30:00 will not be equal to 10:30:00Z (as 10:30:00 will be seen as a local date 10:30:00+05:00, which is not equal to 10:30:00Z).
            </remarks>
            <returns>true if the 2 <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> objects have the same <see cref="P:LiquidTechnologies.XmlObjects.LxDateTime.Type"/> and when converted to UTC have the same value.</returns>
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.LxDuration">
            <summary>
            Holds a xs:duration, xs:dayTimeDuration or xs:yearMonthDuration.<br/>
            The struct is IMMUTABLE
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.LxDuration.Zero">
            <summary>
            The Zero datetime
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.#ctor(System.TimeSpan)">
            <summary>
            Construct a <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> from an <see cref="T:System.TimeSpan"/>
            </summary>
            <param name="ts">The source <see cref="T:System.TimeSpan"/></param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.#ctor(System.UInt16,System.UInt32,System.UInt32,System.UInt32,System.UInt64,System.UInt64,System.UInt16,System.UInt16,System.UInt16,System.Boolean)">
            <summary>
            Construct a <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> from its component parts
            </summary>
            <param name="years">The number of years</param>
            <param name="months">The number of months</param>
            <param name="days">The number of days</param>
            <param name="hours">The number of hours</param>
            <param name="minutes">The number of minutes</param>
            <param name="seconds">The number of seconds</param>
            <param name="millis">The number of milliseconds</param>
            <param name="micros">The number of microseconds</param>
            <param name="nanos">The number of nanoseconds</param>
            <param name="isNegative">Indicates duration is positive or negative</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.ParseXsdDuration(System.String)">
            <summary>
            Parses a string containing an xs:duration
            </summary>
            <param name="xsdDuration">The string representation of an xs:duration</param>
            <returns>An <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> object holding the value of the xs:duration in <paramref name="xsdDuration"/></returns>
            <exception cref="T:System.FormatException">If the <paramref name="xsdDuration"/> is syntactically incorrect.</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.TryParseXsdDuration(System.String,LiquidTechnologies.XmlObjects.LxDuration@,System.Exception@)">
            <summary>
            Parses a string containing an xs:duration
            </summary>
            <param name="xsdDuration">The string representation of an xs:duration</param>
            <param name="result">
            If successful (returns true) then this contains an <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> object holding the value read from <paramref name="xsdDuration"/>.<br/>
            If unsuccessful (returns false) then this value is undefined.<br/>
            </param>
            <param name="ex">
            If successful (returns true) then this is undefined.<br/>
            If unsuccessful (returns false) then this value contains an exception describing the error.<br/>
            </param>
            <returns>
            true if the xs:duration could be parsed successfully, in which case <paramref name="result"/> holds the parsed value.<br/>
            false if the xs:duration could be NOT be parsed successfully, in which case <paramref name="ex"/> holds an exception describing the error.<br/>
            </returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.ParseXsdDayTimeDuration(System.String)">
            <summary>
            Parses a string containing an xs:dayTimeDuration (XSD 1.1)
            </summary>
            <param name="xsdDuration">The string representation of an xs:dayTimeDuration</param>
            <returns>An <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> object holding the value of the xs:dayTimeDuration in <paramref name="xsdDuration"/></returns>
            <exception cref="T:System.FormatException">If the <paramref name="xsdDuration"/> is syntactically incorrect.</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.TryParseXsdDayTimeDuration(System.String,LiquidTechnologies.XmlObjects.LxDuration@,System.Exception@)">
            <summary>
            Parses a string containing an xs:dayTimeDuration (XSD 1.1)
            </summary>
            <param name="xsdDuration">The string representation of an xs:dayTimeDuration</param>
            <param name="result">
            If successful (returns true) then this contains an <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> object holding the value read from <paramref name="xsdDuration"/>.<br/>
            If unsuccessful (returns false) then this value is undefined.<br/>
            </param>
            <param name="ex">
            If successful (returns true) then this is undefined.<br/>
            If unsuccessful (returns false) then this value contains an exception describing the error.<br/>
            </param>
            <returns>
            true if the xs:dayTimeDuration could be parsed successfully, in which case <paramref name="result"/> holds the parsed value.<br/>
            false if the xs:dayTimeDuration could be NOT be parsed successfully, in which case <paramref name="ex"/> holds an exception describing the error.<br/>
            </returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.ParseXsdYearMonthDuration(System.String)">
            <summary>
            Parses a string containing an xs:yearMonthDuration (XSD 1.1)
            </summary>
            <param name="xsdDuration">The string representation of an xs:yearMonthDuration</param>
            <returns>An <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> object holding the value of the xs:yearMonthDuration in <paramref name="xsdDuration"/></returns>
            <exception cref="T:System.FormatException">If the <paramref name="xsdDuration"/> is syntactically incorrect.</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.TryParseXsdYearMonthDuration(System.String,LiquidTechnologies.XmlObjects.LxDuration@,System.Exception@)">
            <summary>
            Parses a string containing an xs:yearMonthDuration (XSD 1.1)
            </summary>
            <param name="xsdDuration">The string representation of an xs:yearMonthDuration</param>
            <param name="result">
            If successful (returns true) then this contains an <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> object holding the value read from <paramref name="xsdDuration"/>.<br/>
            If unsuccessful (returns false) then this value is undefined.<br/>
            </param>
            <param name="ex">
            If successful (returns true) then this is undefined.<br/>
            If unsuccessful (returns false) then this value contains an exception describing the error.<br/>
            </param>
            <returns>
            true if the xs:yearMonthDuration could be parsed successfully, in which case <paramref name="result"/> holds the parsed value.<br/>
            false if the xs:yearMonthDuration could be NOT be parsed successfully, in which case <paramref name="ex"/> holds an exception describing the error.<br/>
            </returns>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.Years">
            <summary>
            The number of Years
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.Months">
            <summary>
            The number of Months
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.Days">
            <summary>
            The number of Days
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.Hours">
            <summary>
            The number of Hours
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.Minutes">
            <summary>
            The number of Minutes
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.Seconds">
            <summary>
            The number of Seconds
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.MilliSeconds">
            <summary>
            The number of MilliSeconds
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.MicroSeconds">
            <summary>
            The number of MicroSeconds
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.NanoSeconds">
            <summary>
            The number of NanoSeconds
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.IsNegative">
            <summary>
            Indicates if this is a negative duration
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.Negate">
            <summary>
            Creates a copy of the <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/> which is the negative of this one.
            </summary>
            <returns>The negative <see cref="T:LiquidTechnologies.XmlObjects.LxDuration"/></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.XsdCompareTo(LiquidTechnologies.XmlObjects.LxDuration)">
            <summary>
            Applies the comparison rules for xs:durations defined in the XSD schema standard
            </summary>
            <param name="dateTimeSpan">The dateTimeSpan to compare</param>
            <returns></returns>
            <remarks>See <see href="https://www.w3.org/TR/xmlschema-2/#duration-order">https://www.w3.org/TR/xmlschema-2/#duration-order</see></remarks>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.LxDuration.Normalized">
            <summary>
            Gets a value which has been Normalized i.e. all values have been overflowed leaving them below there notional maximums.
            </summary>
            <returns>A value with:<br/>
            years (no max)<br/>
            months (max 11)<br/>
            days (no max)<br/>
            hours (max 23)<br/>
            minutes (max 59)<br/>
            seconds (max 59)<br/>
            millis (max 9999)<br/>
            micros (max 9999)<br/>
            nanos (max 9999)<br/>
            </returns>
            <remarks>Note it is not possible to roll days into months as months contain a variable number of days.</remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.op_Inequality(LiquidTechnologies.XmlObjects.LxDuration,LiquidTechnologies.XmlObjects.LxDuration)">
            <summary>
            Compares the raw values 
            </summary>
            <param name="left">One of the values to be compared</param>
            <param name="right">One of the values to be compared</param>
            <returns>true if they are bitwise identical</returns>
            <remarks>
            Will report that 24 hours and 1 day are different.
            For more value based comparisons use the Normalized value.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.op_Equality(LiquidTechnologies.XmlObjects.LxDuration,LiquidTechnologies.XmlObjects.LxDuration)">
            <summary>
            Compares the raw values 
            </summary>
            <param name="left">One of the values to be compared</param>
            <param name="right">One of the values to be compared</param>
            <returns>true if they are bitwise identical</returns>
            <remarks>
            Will report that 24 hours and 1 day are different.
            For more value based comparisons use the Normalized value.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.LxDuration.Equals(System.Object)">
            <summary>
            Compares the raw values 
            </summary>
            <param name="o">The value to be compared</param>
            <returns>true if they are bitwise identical</returns>
            <remarks>
            Will report that 24 hours and 1 day are different.
            For more value based comparisons use the Normalized value.
            </remarks>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.XsdTypeInfo">
            <summary>
            A utility class to provide information about the type XSD types.
            </summary>
        </member>
        <member name="F:LiquidTechnologies.XmlObjects.XsdTypeInfo.XsdSchemaNamespaceUri">
            <summary>
            The XSD namespace
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdTypeInfo.GetQualifiedName(LiquidTechnologies.XmlObjects.Attribution.XsdType)">
            <summary>
            Gets the qualified name for an <see cref="T:LiquidTechnologies.XmlObjects.Attribution.XsdType"/>
            </summary>
            <param name="xsdType"></param>
            <returns></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdTypeInfo.GetXsdTypeFromQualifiedName(System.Xml.XmlQualifiedName)">
            <summary>
            Gets the <see cref="T:LiquidTechnologies.XmlObjects.Attribution.XsdType"/> from its qualified name (XSD 1.0 and 1.1 types are allowed)
            </summary>
            <param name="xsdTypeName">the qualified name of the XSD type</param>
            <returns>The appropriate <see cref="T:LiquidTechnologies.XmlObjects.Attribution.XsdType"/></returns>
            <exception cref="T:System.ArgumentException">If the <paramref name="xsdTypeName"/> is not an xsd type</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdTypeInfo.ToNativeType(LiquidTechnologies.XmlObjects.Attribution.XsdType)">
            <summary>
            Gets the native type used to represent an <see cref="T:LiquidTechnologies.XmlObjects.Attribution.XsdType"/>
            </summary>
            <param name="xsdType">The xsd type to get the native (.Net) type that is used to represent it</param>
            <returns>The native (.Net) type that is used to represent <paramref name="xsdType"/></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdTypeInfo.EmptyNilValue(LiquidTechnologies.XmlObjects.Attribution.XsdType)">
            <summary>
            Gets a value that can be passed to the LxNillable class when it is created with xsi:nil="true"
            </summary>
            <param name="xsdType">The xsd type to get the native (.Net) type that is used to represent it</param>
            <returns>The native (.Net) type that is used to represent <paramref name="xsdType"/></returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.IUnion">
            <summary>
            Allows an xs:union to be modelled in C#, creating a type that can
            contain a number of simple types (i.e. float, int, <see cref="T:LiquidTechnologies.XmlObjects.LxDateTime"/> etc) 
            in a single container.
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.IUnion.Value">
            <summary>
            The untyped value of the item in the union (as object)
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.IUnion.Description">
            <summary>
            A description of the value in the union
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`1">
            <inheritdoc cref="T:LiquidTechnologies.XmlObjects.IUnion"/>
            <typeparam name="T1">An allowable type within the union</typeparam>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)">
            <summary>
            Constructs the union with the given type
            </summary>
            <param name="value">The value to contain within the union</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}">
            <summary>
            Implicitly converts an acceptable value type to a union
            </summary>
            <param name="value">the value to implicitly convert</param>
            <returns>A union containing the <paramref name="value"/></returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0">
            <summary>
            Implicitly converts a union to its value type
            </summary>
            <param name="union">the union to implicitly convert to a value</param>
            <returns>The type contained within the union</returns>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`1.Type1">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T1"/>
            </summary>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`1.Value">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.IUnion.Value"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`1.Description">
            <inheritdoc cref="P:LiquidTechnologies.XmlObjects.IUnion.Description"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`1.GetTypeName(System.Type)">
            <summary>
            Gets a string containing the of the value in the union
            </summary>
            <param name="t"></param>
            <returns>The name of the contained type</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`1.ToString">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`1.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`1.Equals(System.Object)">
            <summary>
            Considered equal if the value contained in the unions is the same
            (regardless of the type of the union).
            </summary>
            <param name="obj"></param>
            <inheritdoc/>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`2">
            <typeparam name="T1">An allowable type within the union</typeparam>
            <typeparam name="T2">An allowable type within the union</typeparam>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`2.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`2.#ctor(`0)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`2.#ctor(`1)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`2.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0,`1}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`2.op_Implicit(`1)~LiquidTechnologies.XmlObjects.Union{`0,`1}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`2.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1})~`0">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`2.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1})~`1">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`2.Type2">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T2"/>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`3">
            <typeparam name="T1">An allowable type within the union</typeparam>
            <typeparam name="T2">An allowable type within the union</typeparam>
            <typeparam name="T3">An allowable type within the union</typeparam>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.#ctor(`0)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.#ctor(`1)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.#ctor(`2)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.op_Implicit(`1)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.op_Implicit(`2)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2})~`0">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2})~`1">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`3.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2})~`2">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`3.Type3">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T3"/>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`4">
            <typeparam name="T1">An allowable type within the union</typeparam>
            <typeparam name="T2">An allowable type within the union</typeparam>
            <typeparam name="T3">An allowable type within the union</typeparam>
            <typeparam name="T4">An allowable type within the union</typeparam>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.#ctor(`0)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.#ctor(`1)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.#ctor(`2)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.#ctor(`3)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.op_Implicit(`1)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.op_Implicit(`2)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.op_Implicit(`3)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3})~`0">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3})~`1">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3})~`2">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`4.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3})~`3">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`4.Type4">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T4"/>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`5">
            <typeparam name="T1">An allowable type within the union</typeparam>
            <typeparam name="T2">An allowable type within the union</typeparam>
            <typeparam name="T3">An allowable type within the union</typeparam>
            <typeparam name="T4">An allowable type within the union</typeparam>
            <typeparam name="T5">An allowable type within the union</typeparam>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.#ctor(`0)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.#ctor(`1)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.#ctor(`2)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.#ctor(`3)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.#ctor(`4)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(`1)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(`2)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(`3)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(`4)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4})~`0">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4})~`1">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4})~`2">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4})~`3">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`5.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4})~`4">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`5.Type5">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T5"/>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`6">
            <typeparam name="T1">An allowable type within the union</typeparam>
            <typeparam name="T2">An allowable type within the union</typeparam>
            <typeparam name="T3">An allowable type within the union</typeparam>
            <typeparam name="T4">An allowable type within the union</typeparam>
            <typeparam name="T5">An allowable type within the union</typeparam>
            <typeparam name="T6">An allowable type within the union</typeparam>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.#ctor(`0)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.#ctor(`1)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.#ctor(`2)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.#ctor(`3)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.#ctor(`4)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.#ctor(`5)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(`1)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(`2)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(`3)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(`4)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(`5)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5})~`0">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5})~`1">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5})~`2">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5})~`3">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5})~`4">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`6.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5})~`5">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`6.Type6">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T6"/>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`7">
            <typeparam name="T1">An allowable type within the union</typeparam>
            <typeparam name="T2">An allowable type within the union</typeparam>
            <typeparam name="T3">An allowable type within the union</typeparam>
            <typeparam name="T4">An allowable type within the union</typeparam>
            <typeparam name="T5">An allowable type within the union</typeparam>
            <typeparam name="T6">An allowable type within the union</typeparam>
            <typeparam name="T7">An allowable type within the union</typeparam>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.#ctor(`0)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.#ctor(`1)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.#ctor(`2)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.#ctor(`3)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.#ctor(`4)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.#ctor(`5)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.#ctor(`6)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(`1)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(`2)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(`3)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(`4)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(`5)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(`6)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6})~`0">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6})~`1">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6})~`2">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6})~`3">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6})~`4">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6})~`5">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`7.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6})~`6">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`7.Type7">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T7"/>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`8">
            <typeparam name="T1">An allowable type within the union</typeparam>
            <typeparam name="T2">An allowable type within the union</typeparam>
            <typeparam name="T3">An allowable type within the union</typeparam>
            <typeparam name="T4">An allowable type within the union</typeparam>
            <typeparam name="T5">An allowable type within the union</typeparam>
            <typeparam name="T6">An allowable type within the union</typeparam>
            <typeparam name="T7">An allowable type within the union</typeparam>
            <typeparam name="T8">An allowable type within the union</typeparam>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(`0)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(`1)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(`2)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(`3)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(`4)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(`5)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(`6)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.#ctor(`7)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(`1)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(`2)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(`3)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(`4)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(`5)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(`6)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(`7)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7})~`0">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7})~`1">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7})~`2">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7})~`3">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7})~`4">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7})~`5">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7})~`6">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`8.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7})~`7">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`8.Type8">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T8"/>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.Union`9">
            <typeparam name="T1">An allowable type within the union</typeparam>
            <typeparam name="T2">An allowable type within the union</typeparam>
            <typeparam name="T3">An allowable type within the union</typeparam>
            <typeparam name="T4">An allowable type within the union</typeparam>
            <typeparam name="T5">An allowable type within the union</typeparam>
            <typeparam name="T6">An allowable type within the union</typeparam>
            <typeparam name="T7">An allowable type within the union</typeparam>
            <typeparam name="T8">An allowable type within the union</typeparam>
            <typeparam name="T9">An allowable type within the union</typeparam>
            <inheritdoc/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(System.Object)">
            <exclude />
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`0)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`1)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`2)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`3)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`4)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`5)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`6)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`7)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.#ctor(`8)">
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.#ctor(`0)"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`1)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`2)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`3)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`4)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`5)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`6)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`7)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(`8)~LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8}">
            <param name="value">the value to implicitly convert</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0})~`0"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`0">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`1">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`2">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`3">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`4">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`5">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`6">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`7">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.Union`9.op_Implicit(LiquidTechnologies.XmlObjects.Union{`0,`1,`2,`3,`4,`5,`6,`7,`8})~`8">
            <param name="union">the union to implicitly convert to a value</param>
            <inheritdoc cref="M:LiquidTechnologies.XmlObjects.Union`1.op_Implicit(`0)~LiquidTechnologies.XmlObjects.Union{`0}"/>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.Union`9.Type9">
            <summary>
            Gets the strongly typed value for type <typeparamref name="T9"/>
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.WhitespaceUtilities">
            <summary>
            A utility class to provide the xsd whitespace rules.
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.WhitespaceUtilities.Preserve(System.String)">
            <summary>
            Applies the xsd whitespace rule 'preserve' to the <paramref name="text"/>
            </summary>
            <param name="text">The string to apply the whitespace rule to</param>
            <remarks>
            Implements the xsd whitespace rule preserve: 
                No normalization is done, the value is not changed (this is the behaviour required by [XML 1.0 (Second Edition)] for element content).
            </remarks>
            <returns>The <paramref name="text"/> value after the whitespace rule has been applied</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.WhitespaceUtilities.Replace(System.String)">
            <summary>
            Applies the xsd whitespace rule 'replace' to the <paramref name="text"/>
            </summary>
            <param name="text">The string to apply the whitespace rule to</param>
            <remarks>
            Implements the xsd whitespace rule replace: 
                All occurrences of #x9 (tab), #xA (line feed) and #xD (carriage return) are replaced with #x20 (space).
            </remarks>
            <returns>The <paramref name="text"/> value after the whitespace rule has been applied</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.WhitespaceUtilities.Collapse(System.String)">
            <summary>
            Applies the xsd whitespace rule 'replace' to the <paramref name="text"/>
            </summary>
            <param name="text">The string to apply the whitespace rule to</param>
            <remarks>
            Implements the xsd whitespace rule collapse: 
                All occurrences of #x9 (tab), #xA (line feed) and #xD (carriage return) are replaced with #x20 (space).
                Contiguous sequences of #x20's are collapsed to a single #x20, and leading and trailing #x20's are removed.
            </remarks>
            <returns>The <paramref name="text"/> value after the whitespace rule has been applied</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.WhitespaceUtilities.ApplyRule(LiquidTechnologies.XmlObjects.Attribution.WhiteSpaceType,System.String)">
            <summary>
            Applies the <paramref name="wsRule"/> whitespace rule to the <paramref name="text"/> value
            </summary>
            <param name="wsRule">The whitespace rule to apply</param>
            <param name="text">The text to apply the rule to</param>
            <returns></returns>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.XsdValidator">
            <summary>
            A class for performing validation based on the original XSD schemas (XSD 1.0 only).
            </summary>
            <remarks>
            An <see cref="P:LiquidTechnologies.XmlObjects.XsdValidator.XmlSchemaSet"/> is constructed containing the source XSD schemas, this can then be used 
            to perform validation on XML instance documents.
            </remarks>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.#ctor(System.Reflection.Assembly,System.String)">
            <summary>
            Initialises the class by loading the schema set by loading the schemas from the <paramref name="resourcePath"/> in the specified <paramref name="assembly"/>.
            </summary>
            <param name="assembly">The assembly containing the resources</param>
            <param name="resourcePath">The path to the XSD schemas in the resources</param>
        </member>
        <member name="P:LiquidTechnologies.XmlObjects.XsdValidator.XmlSchemaSet">
            <summary>
            The compiled schema set which can be used to validate XML instance documents
            </summary>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.Validate(System.Xml.XmlReader,System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Validates the data in the <paramref name="xmlReader"/>
            </summary>
            <param name="xmlReader">The <see cref="T:System.Xml.XmlReader"/> containing the XML data to validate</param>
            <param name="errorHandler">The error handler to report any errors</param>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.Validate(System.IO.TextReader,System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Validates the data in the <paramref name="textReader"/>
            </summary>
            <param name="textReader">The <see cref="T:System.IO.TextReader"/> containing the XML data to validate</param>
            <param name="errorHandler">The error handler to report any errors</param>
            <exception cref="T:System.Xml.XmlException">If the XML data is badly formed</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.Validate(System.IO.Stream,System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Validates the data in the <paramref name="stream"/>
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> containing the XML data to validate</param>
            <param name="errorHandler">The error handler to report any errors</param>
            <exception cref="T:System.Xml.XmlException">If the XML data is badly formed</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.Validate(System.String,System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Validates the data in the <paramref name="filename"/>
            </summary>
            <param name="filename">The XML file to validate</param>
            <param name="errorHandler">The error handler to report any errors</param>
            <exception cref="T:System.Xml.XmlException">If the XML data is badly formed</exception>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.CreateValidatingReader(System.Xml.XmlReader,System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Creates a validating <see cref="T:System.Xml.XmlReader"/> that can be used to read and validate the data in the <paramref name="xmlReader"/>
            </summary>
            <param name="xmlReader">The XML data to validate</param>
            <param name="errorHandler">The error handler to report any errors</param>
            <returns>A validating <see cref="T:System.Xml.XmlReader"/>.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.CreateValidatingReader(System.IO.TextReader,System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Creates a validating <see cref="T:System.Xml.XmlReader"/> that can be used to read and validate the data in the <paramref name="textReader"/>
            </summary>
            <param name="textReader">The <see cref="T:System.IO.TextReader"/> to read the XML data from </param>
            <param name="errorHandler">The error handler to report any errors</param>
            <returns>A validating <see cref="T:System.Xml.XmlReader"/>.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.CreateValidatingReader(System.IO.Stream,System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Creates a validating <see cref="T:System.Xml.XmlReader"/> that can be used to read and validate the data in the <paramref name="stream"/>
            </summary>
            <param name="stream">The <see cref="T:System.IO.Stream"/> to read the XML data from </param>
            <param name="errorHandler">The error handler to report any errors</param>
            <returns>A validating <see cref="T:System.Xml.XmlReader"/>.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.CreateValidatingReader(System.String,System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Creates a validating <see cref="T:System.Xml.XmlReader"/> that can be used to read and validate the data in the <paramref name="filename"/>
            </summary>
            <param name="filename">The  to read the XML data from </param>
            <param name="errorHandler">The error handler to report any errors</param>
            <returns>A validating <see cref="T:System.Xml.XmlReader"/>.</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.CreateReaderSettings(System.Xml.Schema.ValidationEventHandler)">
            <summary>
            Creates the <see cref="T:System.Xml.XmlReaderSettings"/> used by all the validation methods
            </summary>
            <param name="errorHandler">The handler that will receive errors and warnings that arise during validation.</param>
            <returns>A <see cref="T:System.Xml.XmlReaderSettings"/> object initialised with the appropriate settings</returns>
        </member>
        <member name="M:LiquidTechnologies.XmlObjects.XsdValidator.ValidationEventHandler(System.Object,System.Xml.Schema.ValidationEventArgs)">
            <summary>
            Error Handler - throws on errors - ignores warnings
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.XsdValidator.ResourceResolver">
            <summary>
            A resolver that loads the XSD files from the resources
            </summary>
        </member>
        <member name="T:LiquidTechnologies.XmlObjects.XsdValidator.SchemaInfo">
            <summary>
            Holds information about the schemas to be loaded into the schema set
            </summary>
        </member>
    </members>
</doc>
